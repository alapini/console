# This is an action
type Action implements Node {
  id: ID!
  isActive: Boolean!
  description: String
  triggerType: ActionTriggerType!
  handlerType: ActionHandlerType!
  triggerMutationModel: ActionTriggerMutationModel
  triggerMutationRelation: ActionTriggerMutationRelation
  handlerWebhook: ActionHandlerWebhook
}

# A connection to a list of items.
type ActionConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [ActionEdge]
}

# An edge in a connection.
type ActionEdge {
  # The item at the end of the edge.
  node: Action!

  # A cursor for use in pagination.
  cursor: String!
}

enum ActionHandlerType {
  WEBHOOK
}

# This is an ActionHandlerWebhook
type ActionHandlerWebhook implements Node {
  id: ID!
  url: String!
  isAsync: Boolean!
}

input ActionHandlerWebhookEmbed {
  url: String!
  isAsync: Boolean
}

input ActionTriggerModelMutationEmbed {
  fragment: String!
  modelId: ID!
  mutationType: ActionTriggerMutationModelMutationType!
}

# This is an ActionTriggerMutationModel
type ActionTriggerMutationModel implements Node {
  id: ID!
  fragment: String!
  model: Model!
  mutationType: ActionTriggerMutationModelMutationType!
}

enum ActionTriggerMutationModelMutationType {
  CREATE
  UPDATE
  DELETE
}

enum ActionTriggerMutationModelRelationType {
  ADD
  REMOVE
}

# This is an ActionTriggerMutationRelation
type ActionTriggerMutationRelation implements Node {
  id: ID!
  fragment: String!
  relation: Relation!
  mutationType: ActionTriggerMutationModelRelationType!
}

enum ActionTriggerType {
  MUTATION_MODEL
  MUTATION_RELATION
}

input AddActionInput {
  projectId: ID!
  isActive: Boolean!
  description: String
  triggerType: ActionTriggerType!
  handlerType: ActionHandlerType!
  handlerWebhook: ActionHandlerWebhookEmbed
  triggerMutationModel: ActionTriggerModelMutationEmbed
  clientMutationId: String
}

type AddActionPayload {
  viewer: Viewer!
  project: Project!
  user: Customer!
  action: Action!
  actionConnection(before: String, after: String, first: Int, last: Int): ActionConnection!
  actionEdge: ActionEdge!
  clientMutationId: String
}

input AddAlgoliaSyncQueryInput {
  modelId: String!
  indexName: String!
  fragment: String!
  clientMutationId: String
}

type AddAlgoliaSyncQueryPayload {
  viewer: Viewer!
  project: Project!
  algoliaSyncQuery: AlgoliaSyncQuery!
  searchProviderAlgolia: SearchProviderAlgolia!
  user: Customer!
  algoliaSyncQueryConnection(before: String, after: String, first: Int, last: Int): AlgoliaSyncQueryConnection!
  algoliaSyncQueryEdge: AlgoliaSyncQueryEdge!
  clientMutationId: String
}

input AddCustomMutationFunctionInput {
  projectId: ID!
  isActive: Boolean!
  name: String!
  schema: String!
  type: FunctionType!
  webhookUrl: String
  webhookHeaders: String
  inlineCode: String
  auth0Id: String
  clientMutationId: String
}

type AddCustomMutationFunctionPayload {
  viewer: Viewer!
  project: Project!
  user: Customer!
  function: CustomMutationFunction!
  functionEdge: FunctionEdge!
  clientMutationId: String
}

input AddCustomQueryFunctionInput {
  projectId: ID!
  isActive: Boolean!
  name: String!
  schema: String!
  type: FunctionType!
  webhookUrl: String
  webhookHeaders: String
  inlineCode: String
  auth0Id: String
  clientMutationId: String
}

type AddCustomQueryFunctionPayload {
  viewer: Viewer!
  project: Project!
  user: Customer!
  function: CustomQueryFunction!
  functionEdge: FunctionEdge!
  clientMutationId: String
}

input AddEnumInput {
  projectId: ID!
  name: String!
  values: [String!]!
  clientMutationId: String
}

type AddEnumPayload {
  viewer: Viewer!
  project: Project!
  enum: Enum!
  enumEdge: EnumEdge!
  clientMutationId: String
}

input AddFieldConstraintInput {
  fieldId: ID!
  constraintType: FieldConstraintTypeType!
  equalsString: String
  oneOfString: [String!]
  minLength: Int
  maxLength: Int
  startsWith: String
  endsWith: String
  includes: String
  regex: String
  equalsNumber: Float
  oneOfNumber: [Float!]
  min: Float
  max: Float
  exclusiveMin: Float
  exclusiveMax: Float
  multipleOf: Float
  equalsBoolean: Boolean
  uniqueItems: Boolean
  minItems: Int
  maxItems: Int
  clientMutationId: String
}

type AddFieldConstraintPayload {
  viewer: Viewer!
  project: Project!
  field: Field!
  constraints: [FieldConstraint!]!
  clientMutationId: String
}

input AddFieldInput {
  modelId: ID!
  name: String!
  typeIdentifier: String!
  isRequired: Boolean!
  isList: Boolean!
  isUnique: Boolean!
  relationId: String
  enumId: ID
  defaultValue: String
  migrationValue: String
  description: String
  clientMutationId: String
}

type AddFieldPayload {
  viewer: Viewer!
  project: Project!
  user: Customer!
  model: Model!
  field: Field!
  fieldConnection(before: String, after: String, first: Int, last: Int): FieldConnection!
  fieldEdge: FieldEdge!
  clientMutationId: String
}

input AddModelInput {
  projectId: ID!
  modelName: String!
  description: String
  clientMutationId: String
}

type AddModelPayload {
  viewer: Viewer!
  project: Project!
  user: Customer!
  model: Model!
  modelConnection(before: String, after: String, first: Int, last: Int): ModelConnection!
  modelEdge: ModelEdge!
  clientMutationId: String
}

input AddModelPermissionInput {
  modelId: ID!
  operation: Operation!
  userType: UserType!
  rule: Rule!
  ruleName: String
  ruleGraphQuery: String
  ruleWebhookUrl: String
  fieldIds: [String!]!
  applyToWholeModel: Boolean!
  description: String
  isActive: Boolean!
  clientMutationId: String
}

type AddModelPermissionPayload {
  viewer: Viewer!
  project: Project!
  user: Customer!
  model: Model!
  modelPermission: ModelPermission!
  modelPermissionConnection(before: String, after: String, first: Int, last: Int): ModelPermissionConnection!
  modelPermissionEdge: ModelPermissionEdge!
  clientMutationId: String
}

input AddPermanentAuthTokenInput {
  projectId: ID!
  name: String!
  description: String
  clientMutationId: String
}

type AddPermanentAuthTokenPayload {
  viewer: Viewer!
  project: Project!
  user: Customer!
  permanentAuthToken: PermanentAuthToken!
  permanentAuthTokenConnection(before: String, after: String, first: Int, last: Int): PermanentAuthTokenConnection!
  permanentAuthTokenEdge: PermanentAuthTokenEdge!
  clientMutationId: String
}

input AddProjectInput {
  name: String!
  alias: String
  webhookUrl: String
  schema: String
  region: Region
  clientMutationId: String
}

type AddProjectPayload {
  viewer: Viewer!
  project: Project!
  user: Customer!
  projectConnection(before: String, after: String, first: Int, last: Int): ProjectConnection!
  projectEdge: ProjectEdge!
  clientMutationId: String
}

input AddRelationFieldMirrorInput {
  fieldId: ID!
  relationId: ID!
  clientMutationId: String
}

type AddRelationFieldMirrorPayload {
  viewer: Viewer!
  project: Project!
  user: Customer!
  relationFieldMirror: RelationFieldMirror!
  relation: Relation!
  relationFieldMirrorConnection(before: String, after: String, first: Int, last: Int): RelationFieldMirrorConnection!
  relationFieldMirrorEdge: RelationFieldMirrorEdge!
  clientMutationId: String
}

input AddRelationInput {
  projectId: ID!
  leftModelId: ID!
  rightModelId: ID!
  fieldOnLeftModelName: String!
  fieldOnRightModelName: String!
  fieldOnLeftModelIsList: Boolean!
  fieldOnRightModelIsList: Boolean!

  # Defaults to false. Can only be true for non-list relation fields
  fieldOnLeftModelIsRequired: Boolean

  # Defaults to false. Can only be true for non-list relation fields
  fieldOnRightModelIsRequired: Boolean
  name: String!
  description: String
  clientMutationId: String
}

type AddRelationPayload {
  viewer: Viewer!
  project: Project!
  user: Customer!
  relation: Relation!
  leftModel: Model!
  rightModel: Model!
  modelConnection(before: String, after: String, first: Int, last: Int): ModelConnection!
  relationEdge: RelationEdge!
  leftModelEdge: ModelEdge!
  rightModelEdge: ModelEdge!
  fieldEdge: FieldEdge!
  fieldOnLeftModelEdge: FieldEdge!
  fieldOnRightModelEdge: FieldEdge!
  clientMutationId: String
}

input AddRelationPermissionInput {
  relationId: ID!
  connect: Boolean!
  disconnect: Boolean!
  userType: UserType!
  rule: Rule!
  ruleName: String
  ruleGraphQuery: String
  ruleWebhookUrl: String
  description: String
  isActive: Boolean!
  clientMutationId: String
}

type AddRelationPermissionPayload {
  viewer: Viewer!
  project: Project!
  user: Customer!
  relation: Relation!
  relationPermission: RelationPermission!
  relationPermissionConnection(before: String, after: String, first: Int, last: Int): RelationPermissionConnection!
  relationPermissionEdge: RelationPermissionEdge!
  clientMutationId: String
}

input AddRequestPipelineMutationFunctionInput {
  projectId: ID!
  name: String!
  isActive: Boolean!
  binding: FunctionBinding!
  modelId: String!
  operation: RequestPipelineMutationOperation!
  type: FunctionType!
  webhookUrl: String
  webhookHeaders: String
  inlineCode: String
  auth0Id: String
  clientMutationId: String
}

type AddRequestPipelineMutationFunctionPayload {
  viewer: Viewer!
  project: Project!
  user: Customer!
  function: RequestPipelineMutationFunction!
  functionEdge: FunctionEdge!
  clientMutationId: String
}

input AddSchemaExtensionFunctionInput {
  projectId: ID!
  isActive: Boolean!
  name: String!
  schema: String!
  type: FunctionType!
  webhookUrl: String
  webhookHeaders: String
  inlineCode: String
  auth0Id: String
  clientMutationId: String
}

type AddSchemaExtensionFunctionPayload {
  viewer: Viewer!
  project: Project!
  user: Customer!
  function: SchemaExtensionFunction!
  functionEdge: FunctionEdge!
  clientMutationId: String
}

input AddServerSideSubscriptionFunctionInput {
  projectId: ID!
  name: String!
  isActive: Boolean!
  query: String!
  type: FunctionType!
  webhookUrl: String
  webhookHeaders: String
  inlineCode: String
  auth0Id: String
  clientMutationId: String
}

type AddServerSideSubscriptionFunctionPayload {
  viewer: Viewer!
  project: Project!
  user: Customer!
  function: ServerSideSubscriptionFunction!
  functionEdge: FunctionEdge!
  clientMutationId: String
}

# This is an AlgoliaSyncQuery
type AlgoliaSyncQuery implements Node {
  id: ID!
  indexName: String!
  fragment: String!
  isEnabled: Boolean!
  model: Model!
}

# A connection to a list of items.
type AlgoliaSyncQueryConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [AlgoliaSyncQueryEdge]
}

# An edge in a connection.
type AlgoliaSyncQueryEdge {
  # The item at the end of the edge.
  node: AlgoliaSyncQuery!

  # A cursor for use in pagination.
  cursor: String!
}

input AuthenticateCustomerInput {
  auth0IdToken: String!
  clientMutationId: String
}

type AuthenticateCustomerPayload {
  viewer: Viewer!
  user: Customer!
  userEdge: ClientEdge!
  token: String!
  clientMutationId: String
}

# This is a AuthProvider
type AuthProvider implements Node {
  id: ID!
  type: AuthProviderType!
  isEnabled: Boolean!
  digits: AuthProviderDigitsMeta
  auth0: AuthProviderAuth0Meta
}

# Auth0 Meta Information
type AuthProviderAuth0Meta {
  clientId: String
  clientSecret: String
  domain: String
}

input AuthProviderAuth0MetaInput {
  clientId: String!
  clientSecret: String!
  domain: String!
}

# A connection to a list of items.
type AuthProviderConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [AuthProviderEdge]
}

# Digits Meta Information
type AuthProviderDigitsMeta {
  consumerKey: String
  consumerSecret: String
}

input AuthProviderDigitsMetaInput {
  consumerKey: String!
  consumerSecret: String!
}

# An edge in a connection.
type AuthProviderEdge {
  # The item at the end of the edge.
  node: AuthProvider!

  # A cursor for use in pagination.
  cursor: String!
}

enum AuthProviderType {
  AUTH_PROVIDER_EMAIL
  AUTH_PROVIDER_DIGITS
  AUTH_PROVIDER_AUTH0
}

# The `BigDecimal` scalar type represents signed fractional values with arbitrary precision.
scalar BigDecimal

# The `BigInt` scalar type represents non-fractional signed whole numeric values. BigInt can represent arbitrary big values.
scalar BigInt

# This is a BooleanConstraint
type BooleanConstraint implements Node, FieldConstraint {
  equalsBoolean: Boolean

  # The id of the object.
  id: ID!
  constraintType: FieldConstraintTypeType!
  fieldId: ID!
}

# An edge in a connection.
type ClientEdge {
  # The item at the end of the edge.
  node: Customer!

  # A cursor for use in pagination.
  cursor: String!
}

input CloneProjectInput {
  projectId: String!
  name: String!
  includeData: Boolean!
  includeMutationCallbacks: Boolean!
  clientMutationId: String
}

type CloneProjectPayload {
  viewer: Viewer!
  project: Project!
  projectConnection(before: String, after: String, first: Int, last: Int): ProjectConnection!
  projectEdge: ProjectEdge!
  user: Customer!
  clientMutationId: String
}

input CreditCardFilter {
  # Logical AND on all given filters.
  AND: [CreditCardFilter!]

  # Logical OR on all given filters.
  OR: [CreditCardFilter!]
  addressCity: String

  # All values that are not equal to given value.
  addressCity_not: String

  # All values that are contained in given list.
  addressCity_in: [String!]

  # All values that are not contained in given list.
  addressCity_not_in: [String!]

  # All values less than the given value.
  addressCity_lt: String

  # All values less than or equal the given value.
  addressCity_lte: String

  # All values greater than the given value.
  addressCity_gt: String

  # All values greater than or equal the given value.
  addressCity_gte: String

  # All values containing the given string.
  addressCity_contains: String

  # All values not containing the given string.
  addressCity_not_contains: String

  # All values starting with the given string.
  addressCity_starts_with: String

  # All values not starting with the given string.
  addressCity_not_starts_with: String

  # All values ending with the given string.
  addressCity_ends_with: String

  # All values not ending with the given string.
  addressCity_not_ends_with: String
  addressCountry: String

  # All values that are not equal to given value.
  addressCountry_not: String

  # All values that are contained in given list.
  addressCountry_in: [String!]

  # All values that are not contained in given list.
  addressCountry_not_in: [String!]

  # All values less than the given value.
  addressCountry_lt: String

  # All values less than or equal the given value.
  addressCountry_lte: String

  # All values greater than the given value.
  addressCountry_gt: String

  # All values greater than or equal the given value.
  addressCountry_gte: String

  # All values containing the given string.
  addressCountry_contains: String

  # All values not containing the given string.
  addressCountry_not_contains: String

  # All values starting with the given string.
  addressCountry_starts_with: String

  # All values not starting with the given string.
  addressCountry_not_starts_with: String

  # All values ending with the given string.
  addressCountry_ends_with: String

  # All values not ending with the given string.
  addressCountry_not_ends_with: String
  addressLine1: String

  # All values that are not equal to given value.
  addressLine1_not: String

  # All values that are contained in given list.
  addressLine1_in: [String!]

  # All values that are not contained in given list.
  addressLine1_not_in: [String!]

  # All values less than the given value.
  addressLine1_lt: String

  # All values less than or equal the given value.
  addressLine1_lte: String

  # All values greater than the given value.
  addressLine1_gt: String

  # All values greater than or equal the given value.
  addressLine1_gte: String

  # All values containing the given string.
  addressLine1_contains: String

  # All values not containing the given string.
  addressLine1_not_contains: String

  # All values starting with the given string.
  addressLine1_starts_with: String

  # All values not starting with the given string.
  addressLine1_not_starts_with: String

  # All values ending with the given string.
  addressLine1_ends_with: String

  # All values not ending with the given string.
  addressLine1_not_ends_with: String
  addressLine2: String

  # All values that are not equal to given value.
  addressLine2_not: String

  # All values that are contained in given list.
  addressLine2_in: [String!]

  # All values that are not contained in given list.
  addressLine2_not_in: [String!]

  # All values less than the given value.
  addressLine2_lt: String

  # All values less than or equal the given value.
  addressLine2_lte: String

  # All values greater than the given value.
  addressLine2_gt: String

  # All values greater than or equal the given value.
  addressLine2_gte: String

  # All values containing the given string.
  addressLine2_contains: String

  # All values not containing the given string.
  addressLine2_not_contains: String

  # All values starting with the given string.
  addressLine2_starts_with: String

  # All values not starting with the given string.
  addressLine2_not_starts_with: String

  # All values ending with the given string.
  addressLine2_ends_with: String

  # All values not ending with the given string.
  addressLine2_not_ends_with: String
  addressState: String

  # All values that are not equal to given value.
  addressState_not: String

  # All values that are contained in given list.
  addressState_in: [String!]

  # All values that are not contained in given list.
  addressState_not_in: [String!]

  # All values less than the given value.
  addressState_lt: String

  # All values less than or equal the given value.
  addressState_lte: String

  # All values greater than the given value.
  addressState_gt: String

  # All values greater than or equal the given value.
  addressState_gte: String

  # All values containing the given string.
  addressState_contains: String

  # All values not containing the given string.
  addressState_not_contains: String

  # All values starting with the given string.
  addressState_starts_with: String

  # All values not starting with the given string.
  addressState_not_starts_with: String

  # All values ending with the given string.
  addressState_ends_with: String

  # All values not ending with the given string.
  addressState_not_ends_with: String
  addressZip: String

  # All values that are not equal to given value.
  addressZip_not: String

  # All values that are contained in given list.
  addressZip_in: [String!]

  # All values that are not contained in given list.
  addressZip_not_in: [String!]

  # All values less than the given value.
  addressZip_lt: String

  # All values less than or equal the given value.
  addressZip_lte: String

  # All values greater than the given value.
  addressZip_gt: String

  # All values greater than or equal the given value.
  addressZip_gte: String

  # All values containing the given string.
  addressZip_contains: String

  # All values not containing the given string.
  addressZip_not_contains: String

  # All values starting with the given string.
  addressZip_starts_with: String

  # All values not starting with the given string.
  addressZip_not_starts_with: String

  # All values ending with the given string.
  addressZip_ends_with: String

  # All values not ending with the given string.
  addressZip_not_ends_with: String
  createdAt: DateTime

  # All values that are not equal to given value.
  createdAt_not: DateTime

  # All values that are contained in given list.
  createdAt_in: [DateTime!]

  # All values that are not contained in given list.
  createdAt_not_in: [DateTime!]

  # All values less than the given value.
  createdAt_lt: DateTime

  # All values less than or equal the given value.
  createdAt_lte: DateTime

  # All values greater than the given value.
  createdAt_gt: DateTime

  # All values greater than or equal the given value.
  createdAt_gte: DateTime
  expMonth: Int

  # All values that are not equal to given value.
  expMonth_not: Int

  # All values that are contained in given list.
  expMonth_in: [Int!]

  # All values that are not contained in given list.
  expMonth_not_in: [Int!]

  # All values less than the given value.
  expMonth_lt: Int

  # All values less than or equal the given value.
  expMonth_lte: Int

  # All values greater than the given value.
  expMonth_gt: Int

  # All values greater than or equal the given value.
  expMonth_gte: Int
  expYear: Int

  # All values that are not equal to given value.
  expYear_not: Int

  # All values that are contained in given list.
  expYear_in: [Int!]

  # All values that are not contained in given list.
  expYear_not_in: [Int!]

  # All values less than the given value.
  expYear_lt: Int

  # All values less than or equal the given value.
  expYear_lte: Int

  # All values greater than the given value.
  expYear_gt: Int

  # All values greater than or equal the given value.
  expYear_gte: Int
  id: ID

  # All values that are not equal to given value.
  id_not: ID

  # All values that are contained in given list.
  id_in: [ID!]

  # All values that are not contained in given list.
  id_not_in: [ID!]

  # All values less than the given value.
  id_lt: ID

  # All values less than or equal the given value.
  id_lte: ID

  # All values greater than the given value.
  id_gt: ID

  # All values greater than or equal the given value.
  id_gte: ID

  # All values containing the given string.
  id_contains: ID

  # All values not containing the given string.
  id_not_contains: ID

  # All values starting with the given string.
  id_starts_with: ID

  # All values not starting with the given string.
  id_not_starts_with: ID

  # All values ending with the given string.
  id_ends_with: ID

  # All values not ending with the given string.
  id_not_ends_with: ID
  last4: Int

  # All values that are not equal to given value.
  last4_not: Int

  # All values that are contained in given list.
  last4_in: [Int!]

  # All values that are not contained in given list.
  last4_not_in: [Int!]

  # All values less than the given value.
  last4_lt: Int

  # All values less than or equal the given value.
  last4_lte: Int

  # All values greater than the given value.
  last4_gt: Int

  # All values greater than or equal the given value.
  last4_gte: Int
  name: String

  # All values that are not equal to given value.
  name_not: String

  # All values that are contained in given list.
  name_in: [String!]

  # All values that are not contained in given list.
  name_not_in: [String!]

  # All values less than the given value.
  name_lt: String

  # All values less than or equal the given value.
  name_lte: String

  # All values greater than the given value.
  name_gt: String

  # All values greater than or equal the given value.
  name_gte: String

  # All values containing the given string.
  name_contains: String

  # All values not containing the given string.
  name_not_contains: String

  # All values starting with the given string.
  name_starts_with: String

  # All values not starting with the given string.
  name_not_starts_with: String

  # All values ending with the given string.
  name_ends_with: String

  # All values not ending with the given string.
  name_not_ends_with: String
  updatedAt: DateTime

  # All values that are not equal to given value.
  updatedAt_not: DateTime

  # All values that are contained in given list.
  updatedAt_in: [DateTime!]

  # All values that are not contained in given list.
  updatedAt_not_in: [DateTime!]

  # All values less than the given value.
  updatedAt_lt: DateTime

  # All values less than or equal the given value.
  updatedAt_lte: DateTime

  # All values greater than the given value.
  updatedAt_gt: DateTime

  # All values greater than or equal the given value.
  updatedAt_gte: DateTime
  projectBillingInformation: ProjectBillingInformationFilter
}

type crm_CreditCard implements Node {
  addressCity: String!
  addressCountry: String!
  addressLine1: String!
  addressLine2: String
  addressState: String
  addressZip: String!
  createdAt: DateTime
  expMonth: Int!
  expYear: Int!
  id: ID!
  last4: Int!
  name: String!
  projectBillingInformation(filter: ProjectBillingInformationFilter): crm_ProjectBillingInformation
  updatedAt: DateTime
}

type crm_Customer implements Node {
  id: ID!
  projects(filter: ProjectFilter, orderBy: ProjectOrderBy, skip: Int, after: String, before: String, first: Int, last: Int): crm_ProjectConnection
  systemBridge(filter: SystemBridgeFilter): crm_SystemBridge
}

# with default value
type crm_CustomerInformation implements Node {
  createdAt: DateTime!
  email: String!
  id: ID!
  isBeta: Boolean!
  name: String!
  referral: String!
  signupPath: String
  signupSource: CUSTOMER_INFORMATION_SIGNUP_SOURCE!
  source: String
  systemBridge(filter: SystemBridgeFilter): crm_SystemBridge
  updatedAt: DateTime!
}

type crm_GuideStatus implements Node {
  createdAt: DateTime
  guide1: Boolean!
  id: ID!
  systemBridge(filter: SystemBridgeFilter): crm_SystemBridge
  updatedAt: DateTime
}

# test
type crm_Invoice implements Node {
  createdAt: DateTime
  id: ID!

  # Will need to be generated somehow and will be used on invoice documents
  invoiceNumber: String
  overageOperations: Float
  overageRequests: Float!
  overageStorage: Float!
  projectBillingInformation(filter: ProjectBillingInformationFilter): crm_ProjectBillingInformation
  stripeChargeDate: DateTime
  stripeChargeId: String
  timestamp: DateTime!
  total: Float!
  updatedAt: DateTime
  usageRequests: [Int!]!
  usageStorage: [Float!]!
  usedSeats: Int!
}

# A connection to a list of items.
type crm_InvoiceConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [crm_InvoiceEdge]

  # Count of filtered result set without considering pagination arguments
  count: Int!
}

# An edge in a connection.
type crm_InvoiceEdge {
  # The item at the end of the edge.
  node: crm_Invoice!

  # A cursor for use in pagination.
  cursor: String!
}

type crm_OnboardingStatus implements Node {
  createdAt: DateTime
  gettingStarted: ONBOARDING_STATUS_GETTING_STARTED!
  gettingStartedCompleted: Boolean!
  gettingStartedExample: ONBOARDING_STATUS_GETTING_STARTED_EXAMPLE
  gettingStartedSkipped: Boolean!
  id: ID!
  systemBridge(filter: SystemBridgeFilter): crm_SystemBridge
  updatedAt: DateTime
}

type crm_Project implements Node {
  createdAt: DateTime
  customer(filter: CustomerFilter): crm_Customer
  id: ID!
  isDeleted: Boolean!
  name: String!
  projectBillingInformation(filter: ProjectBillingInformationFilter): crm_ProjectBillingInformation
  systemProjectId: String!
  updatedAt: DateTime
}

type crm_ProjectBillingInformation implements Node {
  createdAt: DateTime
  creditCard(filter: CreditCardFilter): crm_CreditCard
  id: ID!
  invoices(filter: InvoiceFilter, orderBy: InvoiceOrderBy, skip: Int, after: String, before: String, first: Int, last: Int): crm_InvoiceConnection
  plan: String!
  project(filter: ProjectFilter): crm_Project
  stripeCustomerId: String
  updatedAt: DateTime
}

# A connection to a list of items.
type crm_ProjectConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [crm_ProjectEdge]

  # Count of filtered result set without considering pagination arguments
  count: Int!
}

# An edge in a connection.
type crm_ProjectEdge {
  # The item at the end of the edge.
  node: crm_Project!

  # A cursor for use in pagination.
  cursor: String!
}

type crm_SystemBridge implements Node {
  customer(filter: CustomerFilter): crm_Customer
  guideStatus(filter: GuideStatusFilter): crm_GuideStatus
  id: ID!
  information(filter: CustomerInformationFilter): crm_CustomerInformation
  onboardingStatus(filter: OnboardingStatusFilter): crm_OnboardingStatus
  systemCustomerId: String!
}

# This is a Customer
type Customer implements Node {
  id: ID!
  crm: crm_SystemBridge
  name: String!
  email: String!
  source: CustomerSourceType!
  createdAt: DateTime!
  updatedAt: DateTime!
  projects(before: String, after: String, first: Int, last: Int): ProjectConnection!
}

enum CUSTOMER_INFORMATION_SIGNUP_SOURCE {
  HOMEPAGE
  CLI
  DOCS
  NOT_DEFINED
}

input CustomerFilter {
  # Logical AND on all given filters.
  AND: [CustomerFilter!]

  # Logical OR on all given filters.
  OR: [CustomerFilter!]
  id: ID

  # All values that are not equal to given value.
  id_not: ID

  # All values that are contained in given list.
  id_in: [ID!]

  # All values that are not contained in given list.
  id_not_in: [ID!]

  # All values less than the given value.
  id_lt: ID

  # All values less than or equal the given value.
  id_lte: ID

  # All values greater than the given value.
  id_gt: ID

  # All values greater than or equal the given value.
  id_gte: ID

  # All values containing the given string.
  id_contains: ID

  # All values not containing the given string.
  id_not_contains: ID

  # All values starting with the given string.
  id_starts_with: ID

  # All values not starting with the given string.
  id_not_starts_with: ID

  # All values ending with the given string.
  id_ends_with: ID

  # All values not ending with the given string.
  id_not_ends_with: ID
  projects_every: ProjectFilter
  projects_some: ProjectFilter
  projects_none: ProjectFilter
  systemBridge: SystemBridgeFilter
}

input CustomerInformationFilter {
  # Logical AND on all given filters.
  AND: [CustomerInformationFilter!]

  # Logical OR on all given filters.
  OR: [CustomerInformationFilter!]
  createdAt: DateTime

  # All values that are not equal to given value.
  createdAt_not: DateTime

  # All values that are contained in given list.
  createdAt_in: [DateTime!]

  # All values that are not contained in given list.
  createdAt_not_in: [DateTime!]

  # All values less than the given value.
  createdAt_lt: DateTime

  # All values less than or equal the given value.
  createdAt_lte: DateTime

  # All values greater than the given value.
  createdAt_gt: DateTime

  # All values greater than or equal the given value.
  createdAt_gte: DateTime
  email: String

  # All values that are not equal to given value.
  email_not: String

  # All values that are contained in given list.
  email_in: [String!]

  # All values that are not contained in given list.
  email_not_in: [String!]

  # All values less than the given value.
  email_lt: String

  # All values less than or equal the given value.
  email_lte: String

  # All values greater than the given value.
  email_gt: String

  # All values greater than or equal the given value.
  email_gte: String

  # All values containing the given string.
  email_contains: String

  # All values not containing the given string.
  email_not_contains: String

  # All values starting with the given string.
  email_starts_with: String

  # All values not starting with the given string.
  email_not_starts_with: String

  # All values ending with the given string.
  email_ends_with: String

  # All values not ending with the given string.
  email_not_ends_with: String
  id: ID

  # All values that are not equal to given value.
  id_not: ID

  # All values that are contained in given list.
  id_in: [ID!]

  # All values that are not contained in given list.
  id_not_in: [ID!]

  # All values less than the given value.
  id_lt: ID

  # All values less than or equal the given value.
  id_lte: ID

  # All values greater than the given value.
  id_gt: ID

  # All values greater than or equal the given value.
  id_gte: ID

  # All values containing the given string.
  id_contains: ID

  # All values not containing the given string.
  id_not_contains: ID

  # All values starting with the given string.
  id_starts_with: ID

  # All values not starting with the given string.
  id_not_starts_with: ID

  # All values ending with the given string.
  id_ends_with: ID

  # All values not ending with the given string.
  id_not_ends_with: ID
  isBeta: Boolean

  # All values that are not equal to given value.
  isBeta_not: Boolean
  name: String

  # All values that are not equal to given value.
  name_not: String

  # All values that are contained in given list.
  name_in: [String!]

  # All values that are not contained in given list.
  name_not_in: [String!]

  # All values less than the given value.
  name_lt: String

  # All values less than or equal the given value.
  name_lte: String

  # All values greater than the given value.
  name_gt: String

  # All values greater than or equal the given value.
  name_gte: String

  # All values containing the given string.
  name_contains: String

  # All values not containing the given string.
  name_not_contains: String

  # All values starting with the given string.
  name_starts_with: String

  # All values not starting with the given string.
  name_not_starts_with: String

  # All values ending with the given string.
  name_ends_with: String

  # All values not ending with the given string.
  name_not_ends_with: String
  referral: String

  # All values that are not equal to given value.
  referral_not: String

  # All values that are contained in given list.
  referral_in: [String!]

  # All values that are not contained in given list.
  referral_not_in: [String!]

  # All values less than the given value.
  referral_lt: String

  # All values less than or equal the given value.
  referral_lte: String

  # All values greater than the given value.
  referral_gt: String

  # All values greater than or equal the given value.
  referral_gte: String

  # All values containing the given string.
  referral_contains: String

  # All values not containing the given string.
  referral_not_contains: String

  # All values starting with the given string.
  referral_starts_with: String

  # All values not starting with the given string.
  referral_not_starts_with: String

  # All values ending with the given string.
  referral_ends_with: String

  # All values not ending with the given string.
  referral_not_ends_with: String
  signupPath: String

  # All values that are not equal to given value.
  signupPath_not: String

  # All values that are contained in given list.
  signupPath_in: [String!]

  # All values that are not contained in given list.
  signupPath_not_in: [String!]

  # All values less than the given value.
  signupPath_lt: String

  # All values less than or equal the given value.
  signupPath_lte: String

  # All values greater than the given value.
  signupPath_gt: String

  # All values greater than or equal the given value.
  signupPath_gte: String

  # All values containing the given string.
  signupPath_contains: String

  # All values not containing the given string.
  signupPath_not_contains: String

  # All values starting with the given string.
  signupPath_starts_with: String

  # All values not starting with the given string.
  signupPath_not_starts_with: String

  # All values ending with the given string.
  signupPath_ends_with: String

  # All values not ending with the given string.
  signupPath_not_ends_with: String
  signupSource: CUSTOMER_INFORMATION_SIGNUP_SOURCE

  # All values that are not equal to given value.
  signupSource_not: CUSTOMER_INFORMATION_SIGNUP_SOURCE

  # All values that are contained in given list.
  signupSource_in: [CUSTOMER_INFORMATION_SIGNUP_SOURCE!]

  # All values that are not contained in given list.
  signupSource_not_in: [CUSTOMER_INFORMATION_SIGNUP_SOURCE!]
  source: String

  # All values that are not equal to given value.
  source_not: String

  # All values that are contained in given list.
  source_in: [String!]

  # All values that are not contained in given list.
  source_not_in: [String!]

  # All values less than the given value.
  source_lt: String

  # All values less than or equal the given value.
  source_lte: String

  # All values greater than the given value.
  source_gt: String

  # All values greater than or equal the given value.
  source_gte: String

  # All values containing the given string.
  source_contains: String

  # All values not containing the given string.
  source_not_contains: String

  # All values starting with the given string.
  source_starts_with: String

  # All values not starting with the given string.
  source_not_starts_with: String

  # All values ending with the given string.
  source_ends_with: String

  # All values not ending with the given string.
  source_not_ends_with: String
  updatedAt: DateTime

  # All values that are not equal to given value.
  updatedAt_not: DateTime

  # All values that are contained in given list.
  updatedAt_in: [DateTime!]

  # All values that are not contained in given list.
  updatedAt_not_in: [DateTime!]

  # All values less than the given value.
  updatedAt_lt: DateTime

  # All values less than or equal the given value.
  updatedAt_lte: DateTime

  # All values greater than the given value.
  updatedAt_gt: DateTime

  # All values greater than or equal the given value.
  updatedAt_gte: DateTime
  systemBridge: SystemBridgeFilter
}

enum CustomerSourceType {
  LEARN_RELAY
  LEARN_APOLLO
  DOCS
  WAIT_LIST
}

# This is a CustomMutationFunction
type CustomMutationFunction implements Node, Function {
  schema: String!

  # The id of the object.
  id: ID!
  logs(before: String, after: String, first: Int, last: Int): LogConnection!
  stats(before: String, after: String, first: Int, last: Int): FunctionStats!
  name: String!
  type: FunctionType!
  isActive: Boolean!
  webhookUrl: String
  webhookHeaders: String
  inlineCode: String
  auth0Id: String
}

# This is a CustomQueryFunction
type CustomQueryFunction implements Node, Function {
  schema: String!

  # The id of the object.
  id: ID!
  logs(before: String, after: String, first: Int, last: Int): LogConnection!
  stats(before: String, after: String, first: Int, last: Int): FunctionStats!
  name: String!
  type: FunctionType!
  isActive: Boolean!
  webhookUrl: String
  webhookHeaders: String
  inlineCode: String
  auth0Id: String
}

scalar DateTime

input DeleteActionInput {
  actionId: ID!
  clientMutationId: String
}

type DeleteActionPayload {
  viewer: Viewer!
  project: Project!
  user: Customer!
  action: Action!
  actionConnection(before: String, after: String, first: Int, last: Int): ActionConnection!
  actionEdge: ActionEdge!
  deletedId: String!
  clientMutationId: String
}

input DeleteAlgoliaSyncQueryInput {
  algoliaSyncQueryId: String!
  clientMutationId: String
}

type DeleteAlgoliaSyncQueryPayload {
  viewer: Viewer!
  project: Project!
  algoliaSyncQuery: AlgoliaSyncQuery!
  deletedId: String!
  searchProviderAlgolia: SearchProviderAlgolia!
  user: Customer!
  algoliaSyncQueryConnection(before: String, after: String, first: Int, last: Int): AlgoliaSyncQueryConnection!
  algoliaSyncQueryEdge: AlgoliaSyncQueryEdge!
  clientMutationId: String
}

input DeleteCreditCardInput {
  projectId: ID!
  clientMutationId: String
}

type DeleteCreditCardPayload {
  viewer: Viewer!
  project: Project!
  user: Customer!
  clientMutationId: String
}

input DeleteCustomerInput {
  customerId: String!
  clientMutationId: String
}

type DeleteCustomerPayload {
  viewer: Viewer!
  deletedId: String!
  user: Customer!
  clientMutationId: String
}

input DeleteEnumInput {
  enumId: ID!
  clientMutationId: String
}

type DeleteEnumPayload {
  viewer: Viewer!
  project: Project!
  enum: Enum!
  deletedId: ID!
  clientMutationId: String
}

input DeleteFieldConstraintInput {
  constraintId: ID!
  clientMutationId: String
}

type DeleteFieldConstraintPayload {
  viewer: Viewer!
  project: Project!
  constraint: FieldConstraint!
  deletedId: ID!
  clientMutationId: String
}

input DeleteFieldInput {
  fieldId: String!
  clientMutationId: String
}

type DeleteFieldPayload {
  viewer: Viewer!
  deletedId: String!
  user: Customer!
  model: Model!
  fieldConnection(before: String, after: String, first: Int, last: Int): FieldConnection!
  clientMutationId: String
}

input DeleteFunctionInput {
  functionId: String!
  clientMutationId: String
}

type DeleteFunctionPayload {
  viewer: Viewer!
  project: Project!
  deletedId: String!
  user: Customer!
  clientMutationId: String
}

input DeleteModelInput {
  modelId: String!
  clientMutationId: String
}

type DeleteModelPayload {
  viewer: Viewer!
  deletedId: String!
  deletedRelationFieldIds: [String!]!
  user: Customer!
  project: Project!
  modelConnection(before: String, after: String, first: Int, last: Int): ModelConnection!
  clientMutationId: String
}

input DeleteModelPermissionInput {
  modelPermissionId: String!
  clientMutationId: String
}

type DeleteModelPermissionPayload {
  viewer: Viewer!
  deletedId: String!
  user: Customer!
  model: Model!
  modelPermissionConnection(before: String, after: String, first: Int, last: Int): ModelPermissionConnection!
  clientMutationId: String
}

input DeletePermanentAuthTokenInput {
  permanentAuthTokenId: String!
  clientMutationId: String
}

type DeletePermanentAuthTokenPayload {
  viewer: Viewer!
  project: Project!
  user: Customer!
  deletedId: String!
  permanentAuthTokenConnection(before: String, after: String, first: Int, last: Int): PermanentAuthTokenConnection!
  clientMutationId: String
}

input DeleteProjectInput {
  projectId: String!
  clientMutationId: String
}

type DeleteProjectPayload {
  viewer: Viewer!
  deletedId: String!
  user: Customer!
  projectConnection(before: String, after: String, first: Int, last: Int): ProjectConnection!
  clientMutationId: String
}

input DeleteRelationFieldMirrorInput {
  relationFieldMirrorId: String!
  clientMutationId: String
}

type DeleteRelationFieldMirrorPayload {
  viewer: Viewer!
  project: Project!
  user: Customer!
  deletedId: ID!
  relation: Relation!
  relationFieldMirrorConnection(before: String, after: String, first: Int, last: Int): RelationFieldMirrorConnection!
  clientMutationId: String
}

input DeleteRelationInput {
  relationId: String!
  clientMutationId: String
}

type DeleteRelationPayload {
  viewer: Viewer!
  deletedId: String!
  user: Customer!
  project: Project!
  relationConnection(before: String, after: String, first: Int, last: Int): RelationConnection!
  clientMutationId: String
}

input DeleteRelationPermissionInput {
  relationPermissionId: String!
  clientMutationId: String
}

type DeleteRelationPermissionPayload {
  viewer: Viewer!
  deletedId: String!
  user: Customer!
  relation: Relation!
  relationPermissionConnection(before: String, after: String, first: Int, last: Int): RelationPermissionConnection!
  clientMutationId: String
}

# This is an enum
type Enum implements Node {
  id: ID!
  name: String!
  values: [String!]!
}

# A connection to a list of items.
type EnumConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [EnumEdge]
}

# An edge in a connection.
type EnumEdge {
  # The item at the end of the edge.
  node: Enum!

  # A cursor for use in pagination.
  cursor: String!
}

input ExportDataInput {
  projectId: String!
  clientMutationId: String
}

type ExportDataPayload {
  viewer: Viewer!
  project: Project!
  projectConnection(before: String, after: String, first: Int, last: Int): ProjectConnection!
  projectEdge: ProjectEdge!
  user: Customer!
  url: String!
  clientMutationId: String
}

# The feature toggles of a project.
type FeatureToggle implements Node {
  id: ID!
  name: String!
  isEnabled: Boolean!
}

# A connection to a list of items.
type FeatureToggleConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [FeatureToggleEdge]
}

# An edge in a connection.
type FeatureToggleEdge {
  # The item at the end of the edge.
  node: FeatureToggle!

  # A cursor for use in pagination.
  cursor: String!
}

# This is a field
type Field implements Node {
  id: ID!
  name: String!
  typeIdentifier: String!
  description: String
  isRequired: Boolean!
  isList: Boolean!
  isUnique: Boolean!
  isSystem: Boolean!
  isReadonly: Boolean!
  enum: Enum
  constraints: [FieldConstraint!]!
  defaultValue: String
  relation: Relation
  model: Model
  relatedModel: Model
  relationSide: RelationSide
  reverseRelationField: Field
}

# A connection to a list of items.
type FieldConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [FieldEdge]
}

# This is a FieldConstraint
interface FieldConstraint {
  id: ID!
  constraintType: FieldConstraintTypeType!
  fieldId: ID!
}

enum FieldConstraintTypeType {
  STRING
  NUMBER
  BOOLEAN
  LIST
}

# An edge in a connection.
type FieldEdge {
  # The item at the end of the edge.
  node: Field!

  # A cursor for use in pagination.
  cursor: String!
}

# This is a Function
interface Function {
  id: ID!
  logs(before: String, after: String, first: Int, last: Int): LogConnection!
  stats(before: String, after: String, first: Int, last: Int): FunctionStats!
  name: String!
  type: FunctionType!
  isActive: Boolean!
  webhookUrl: String
  webhookHeaders: String
  inlineCode: String
  auth0Id: String
}

enum FunctionBinding {
  TRANSFORM_ARGUMENT
  PRE_WRITE
  TRANSFORM_PAYLOAD
}

# A connection to a list of items.
type FunctionConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [FunctionEdge]
}

# An edge in a connection.
type FunctionEdge {
  # The item at the end of the edge.
  node: Function!

  # A cursor for use in pagination.
  cursor: String!
}

# This is statistics for a Function
type FunctionStats {
  requestHistogram: [Int!]!
  requestCount: Int!
  errorCount: Int!
  lastRequest: DateTime
}

enum FunctionType {
  WEBHOOK
  AUTH0
}

input GenerateUserTokenInput {
  pat: String!
  projectId: ID!
  userId: ID!
  modelName: ID!
  expirationInSeconds: Int
  clientMutationId: String
}

type GenerateUserTokenPayload {
  token: String!
  clientMutationId: String
}

input GuideStatusFilter {
  # Logical AND on all given filters.
  AND: [GuideStatusFilter!]

  # Logical OR on all given filters.
  OR: [GuideStatusFilter!]
  createdAt: DateTime

  # All values that are not equal to given value.
  createdAt_not: DateTime

  # All values that are contained in given list.
  createdAt_in: [DateTime!]

  # All values that are not contained in given list.
  createdAt_not_in: [DateTime!]

  # All values less than the given value.
  createdAt_lt: DateTime

  # All values less than or equal the given value.
  createdAt_lte: DateTime

  # All values greater than the given value.
  createdAt_gt: DateTime

  # All values greater than or equal the given value.
  createdAt_gte: DateTime
  guide1: Boolean

  # All values that are not equal to given value.
  guide1_not: Boolean
  id: ID

  # All values that are not equal to given value.
  id_not: ID

  # All values that are contained in given list.
  id_in: [ID!]

  # All values that are not contained in given list.
  id_not_in: [ID!]

  # All values less than the given value.
  id_lt: ID

  # All values less than or equal the given value.
  id_lte: ID

  # All values greater than the given value.
  id_gt: ID

  # All values greater than or equal the given value.
  id_gte: ID

  # All values containing the given string.
  id_contains: ID

  # All values not containing the given string.
  id_not_contains: ID

  # All values starting with the given string.
  id_starts_with: ID

  # All values not starting with the given string.
  id_not_starts_with: ID

  # All values ending with the given string.
  id_ends_with: ID

  # All values not ending with the given string.
  id_not_ends_with: ID
  updatedAt: DateTime

  # All values that are not equal to given value.
  updatedAt_not: DateTime

  # All values that are contained in given list.
  updatedAt_in: [DateTime!]

  # All values that are not contained in given list.
  updatedAt_not_in: [DateTime!]

  # All values less than the given value.
  updatedAt_lt: DateTime

  # All values less than or equal the given value.
  updatedAt_lte: DateTime

  # All values greater than the given value.
  updatedAt_gt: DateTime

  # All values greater than or equal the given value.
  updatedAt_gte: DateTime
  systemBridge: SystemBridgeFilter
}

enum HistogramPeriod {
  MONTH
  WEEK
  DAY
  HOUR
  HALF_HOUR
}

input InstallPackageInput {
  projectId: ID!
  definition: String!
  clientMutationId: String
}

type InstallPackagePayload {
  viewer: Viewer!
  project: Project!
  user: Customer!
  packageDefinition: PackageDefinition!
  packageDefinitionConnection(before: String, after: String, first: Int, last: Int): PackageDefinitionConnection!
  packageDefinitionEdge: PackageDefinitionEdge!
  clientMutationId: String
}

# This is an integration. Use inline fragment to get values from the concrete
# type: `{id ... on SearchProviderAlgolia { algoliaSchema }}`
interface Integration {
  id: ID!
  isEnabled: Boolean!
  name: IntegrationNameType!
  type: IntegrationTypeType!
}

# A connection to a list of items.
type IntegrationConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [IntegrationEdge]
}

# An edge in a connection.
type IntegrationEdge {
  # The item at the end of the edge.
  node: Integration!

  # A cursor for use in pagination.
  cursor: String!
}

enum IntegrationNameType {
  AUTH_PROVIDER_AUTH0
  AUTH_PROVIDER_DIGITS
  AUTH_PROVIDER_EMAIL
  SEARCH_PROVIDER_ALGOLIA
}

enum IntegrationTypeType {
  AUTH_PROVIDER
  SEARCH_PROVIDER
}

input InviteCollaboratorInput {
  projectId: ID!
  email: String!
  clientMutationId: String
}

type InviteCollaboratorPayload {
  viewer: Viewer!
  project: Project!
  user: Customer!
  seat: Seat!
  seatConnection(before: String, after: String, first: Int, last: Int): SeatConnection!
  seatEdge: SeatEdge!
  clientMutationId: String
}

input InvoiceFilter {
  # Logical AND on all given filters.
  AND: [InvoiceFilter!]

  # Logical OR on all given filters.
  OR: [InvoiceFilter!]
  createdAt: DateTime

  # All values that are not equal to given value.
  createdAt_not: DateTime

  # All values that are contained in given list.
  createdAt_in: [DateTime!]

  # All values that are not contained in given list.
  createdAt_not_in: [DateTime!]

  # All values less than the given value.
  createdAt_lt: DateTime

  # All values less than or equal the given value.
  createdAt_lte: DateTime

  # All values greater than the given value.
  createdAt_gt: DateTime

  # All values greater than or equal the given value.
  createdAt_gte: DateTime
  id: ID

  # All values that are not equal to given value.
  id_not: ID

  # All values that are contained in given list.
  id_in: [ID!]

  # All values that are not contained in given list.
  id_not_in: [ID!]

  # All values less than the given value.
  id_lt: ID

  # All values less than or equal the given value.
  id_lte: ID

  # All values greater than the given value.
  id_gt: ID

  # All values greater than or equal the given value.
  id_gte: ID

  # All values containing the given string.
  id_contains: ID

  # All values not containing the given string.
  id_not_contains: ID

  # All values starting with the given string.
  id_starts_with: ID

  # All values not starting with the given string.
  id_not_starts_with: ID

  # All values ending with the given string.
  id_ends_with: ID

  # All values not ending with the given string.
  id_not_ends_with: ID
  invoiceNumber: String

  # All values that are not equal to given value.
  invoiceNumber_not: String

  # All values that are contained in given list.
  invoiceNumber_in: [String!]

  # All values that are not contained in given list.
  invoiceNumber_not_in: [String!]

  # All values less than the given value.
  invoiceNumber_lt: String

  # All values less than or equal the given value.
  invoiceNumber_lte: String

  # All values greater than the given value.
  invoiceNumber_gt: String

  # All values greater than or equal the given value.
  invoiceNumber_gte: String

  # All values containing the given string.
  invoiceNumber_contains: String

  # All values not containing the given string.
  invoiceNumber_not_contains: String

  # All values starting with the given string.
  invoiceNumber_starts_with: String

  # All values not starting with the given string.
  invoiceNumber_not_starts_with: String

  # All values ending with the given string.
  invoiceNumber_ends_with: String

  # All values not ending with the given string.
  invoiceNumber_not_ends_with: String
  overageOperations: Float

  # All values that are not equal to given value.
  overageOperations_not: Float

  # All values that are contained in given list.
  overageOperations_in: [Float!]

  # All values that are not contained in given list.
  overageOperations_not_in: [Float!]

  # All values less than the given value.
  overageOperations_lt: Float

  # All values less than or equal the given value.
  overageOperations_lte: Float

  # All values greater than the given value.
  overageOperations_gt: Float

  # All values greater than or equal the given value.
  overageOperations_gte: Float
  overageRequests: Float

  # All values that are not equal to given value.
  overageRequests_not: Float

  # All values that are contained in given list.
  overageRequests_in: [Float!]

  # All values that are not contained in given list.
  overageRequests_not_in: [Float!]

  # All values less than the given value.
  overageRequests_lt: Float

  # All values less than or equal the given value.
  overageRequests_lte: Float

  # All values greater than the given value.
  overageRequests_gt: Float

  # All values greater than or equal the given value.
  overageRequests_gte: Float
  overageStorage: Float

  # All values that are not equal to given value.
  overageStorage_not: Float

  # All values that are contained in given list.
  overageStorage_in: [Float!]

  # All values that are not contained in given list.
  overageStorage_not_in: [Float!]

  # All values less than the given value.
  overageStorage_lt: Float

  # All values less than or equal the given value.
  overageStorage_lte: Float

  # All values greater than the given value.
  overageStorage_gt: Float

  # All values greater than or equal the given value.
  overageStorage_gte: Float
  stripeChargeDate: DateTime

  # All values that are not equal to given value.
  stripeChargeDate_not: DateTime

  # All values that are contained in given list.
  stripeChargeDate_in: [DateTime!]

  # All values that are not contained in given list.
  stripeChargeDate_not_in: [DateTime!]

  # All values less than the given value.
  stripeChargeDate_lt: DateTime

  # All values less than or equal the given value.
  stripeChargeDate_lte: DateTime

  # All values greater than the given value.
  stripeChargeDate_gt: DateTime

  # All values greater than or equal the given value.
  stripeChargeDate_gte: DateTime
  stripeChargeId: String

  # All values that are not equal to given value.
  stripeChargeId_not: String

  # All values that are contained in given list.
  stripeChargeId_in: [String!]

  # All values that are not contained in given list.
  stripeChargeId_not_in: [String!]

  # All values less than the given value.
  stripeChargeId_lt: String

  # All values less than or equal the given value.
  stripeChargeId_lte: String

  # All values greater than the given value.
  stripeChargeId_gt: String

  # All values greater than or equal the given value.
  stripeChargeId_gte: String

  # All values containing the given string.
  stripeChargeId_contains: String

  # All values not containing the given string.
  stripeChargeId_not_contains: String

  # All values starting with the given string.
  stripeChargeId_starts_with: String

  # All values not starting with the given string.
  stripeChargeId_not_starts_with: String

  # All values ending with the given string.
  stripeChargeId_ends_with: String

  # All values not ending with the given string.
  stripeChargeId_not_ends_with: String
  timestamp: DateTime

  # All values that are not equal to given value.
  timestamp_not: DateTime

  # All values that are contained in given list.
  timestamp_in: [DateTime!]

  # All values that are not contained in given list.
  timestamp_not_in: [DateTime!]

  # All values less than the given value.
  timestamp_lt: DateTime

  # All values less than or equal the given value.
  timestamp_lte: DateTime

  # All values greater than the given value.
  timestamp_gt: DateTime

  # All values greater than or equal the given value.
  timestamp_gte: DateTime
  total: Float

  # All values that are not equal to given value.
  total_not: Float

  # All values that are contained in given list.
  total_in: [Float!]

  # All values that are not contained in given list.
  total_not_in: [Float!]

  # All values less than the given value.
  total_lt: Float

  # All values less than or equal the given value.
  total_lte: Float

  # All values greater than the given value.
  total_gt: Float

  # All values greater than or equal the given value.
  total_gte: Float
  updatedAt: DateTime

  # All values that are not equal to given value.
  updatedAt_not: DateTime

  # All values that are contained in given list.
  updatedAt_in: [DateTime!]

  # All values that are not contained in given list.
  updatedAt_not_in: [DateTime!]

  # All values less than the given value.
  updatedAt_lt: DateTime

  # All values less than or equal the given value.
  updatedAt_lte: DateTime

  # All values greater than the given value.
  updatedAt_gt: DateTime

  # All values greater than or equal the given value.
  updatedAt_gte: DateTime
  usedSeats: Int

  # All values that are not equal to given value.
  usedSeats_not: Int

  # All values that are contained in given list.
  usedSeats_in: [Int!]

  # All values that are not contained in given list.
  usedSeats_not_in: [Int!]

  # All values less than the given value.
  usedSeats_lt: Int

  # All values less than or equal the given value.
  usedSeats_lte: Int

  # All values greater than the given value.
  usedSeats_gt: Int

  # All values greater than or equal the given value.
  usedSeats_gte: Int
  projectBillingInformation: ProjectBillingInformationFilter
}

enum InvoiceOrderBy {
  createdAt_ASC
  createdAt_DESC
  id_ASC
  id_DESC
  invoiceNumber_ASC
  invoiceNumber_DESC
  overageOperations_ASC
  overageOperations_DESC
  overageRequests_ASC
  overageRequests_DESC
  overageStorage_ASC
  overageStorage_DESC
  stripeChargeDate_ASC
  stripeChargeDate_DESC
  stripeChargeId_ASC
  stripeChargeId_DESC
  timestamp_ASC
  timestamp_DESC
  total_ASC
  total_DESC
  updatedAt_ASC
  updatedAt_DESC
  usedSeats_ASC
  usedSeats_DESC
}

# This is a ListConstraint
type ListConstraint implements Node, FieldConstraint {
  uniqueItems: Boolean
  minItems: Int
  maxItems: Int

  # The id of the object.
  id: ID!
  constraintType: FieldConstraintTypeType!
  fieldId: ID!
}

# A log is a log is a log
type Log implements Node {
  id: ID!
  requestId: String
  duration: Int!
  status: LogStatus!
  timestamp: DateTime!
  message: String!
}

# A connection to a list of items.
type LogConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [LogEdge]
}

# An edge in a connection.
type LogEdge {
  # The item at the end of the edge.
  node: Log!

  # A cursor for use in pagination.
  cursor: String!
}

enum LogStatus {
  SUCCESS
  FAILURE
}

# The `Long` scalar type represents non-fractional signed whole numeric values.
# Long can represent values between -(2^63) and 2^63 - 1.
scalar Long

input MigrateProjectInput {
  newSchema: String!

  # If set to false the migration is not performed.
  isDryRun: Boolean!

  # If set to false the migration will fail if data would be lost. Defaults to false.
  force: Boolean
  clientMutationId: String
}

type MigrateProjectPayload {
  project: Project
  migrationMessages: [MigrationMessage!]!
  errors: [SchemaError!]!
  clientMutationId: String
}

# verbal descriptions of actions taken during a schema migration
type MigrationMessage {
  type: String!
  action: String!
  name: String!
  description: String!
  subDescriptions: [MigrationSubMessage!]!
}

# verbal descriptions of actions taken during a schema migration
type MigrationSubMessage {
  type: String!
  action: String!
  name: String!
  description: String!
}

# This is a model
type Model implements Node {
  id: ID!
  name: String!
  namePlural: String!
  description: String
  isSystem: Boolean!
  fields(before: String, after: String, first: Int, last: Int): FieldConnection!
  permissions(before: String, after: String, first: Int, last: Int): ModelPermissionConnection!
  itemCount: Int!
  permissionSchema(operation: Operation!): String!
  requestPipelineFunctionSchema(operation: RequestPipelineMutationOperation!, binding: FunctionBinding!): String!
  permissionQueryArguments(operation: Operation!): [PermissionQueryArgument!]!
}

# A connection to a list of items.
type ModelConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [ModelEdge]
}

# An edge in a connection.
type ModelEdge {
  # The item at the end of the edge.
  node: Model!

  # A cursor for use in pagination.
  cursor: String!
}

# This is a model permission
type ModelPermission implements Node {
  id: ID!
  fieldIds: [String!]!
  ruleWebhookUrl: String
  rule: Rule!
  ruleName: String
  ruleGraphQuery: String
  applyToWholeModel: Boolean!
  isActive: Boolean!
  operation: Operation!
  userType: UserType!
  description: String
  model: Model!
}

# A connection to a list of items.
type ModelPermissionConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [ModelPermissionEdge]
}

# An edge in a connection.
type ModelPermissionEdge {
  # The item at the end of the edge.
  node: ModelPermission!

  # A cursor for use in pagination.
  cursor: String!
}

type Mutation {
  signinCustomer(input: SigninCustomerInput!): SigninCustomerPayload
  authenticateCustomer(input: AuthenticateCustomerInput!): AuthenticateCustomerPayload
  signupCustomer(input: SignupCustomerInput!): SignupCustomerPayload
  trustedSignupCustomer(input: TrustedSignupCustomerInput!): TrustedSignupCustomerPayload
  signinClientUser(input: SigninClientUserInput!): SigninClientUserPayload
  trustedSigninCustomer(input: TrustedSigninCustomerInput!): TrustedSigninCustomerPayload
  updateCustomer(input: UpdateCustomerInput!): UpdateCustomerPayload
  updatePassword(input: UpdatePasswordInput!): UpdatePasswordPayload
  resetPassword(input: ResetPasswordInput!): ResetPasswordPayload
  addField(input: AddFieldInput!): AddFieldPayload
  addModel(input: AddModelInput!): AddModelPayload
  addRelation(input: AddRelationInput!): AddRelationPayload
  addProject(input: AddProjectInput!): AddProjectPayload
  deleteProject(input: DeleteProjectInput!): DeleteProjectPayload
  deleteCustomer(input: DeleteCustomerInput!): DeleteCustomerPayload
  deleteField(input: DeleteFieldInput!): DeleteFieldPayload
  deleteModel(input: DeleteModelInput!): DeleteModelPayload
  deleteRelation(input: DeleteRelationInput!): DeleteRelationPayload
  updateProject(input: UpdateProjectInput!): UpdateProjectPayload
  trustedSetProjectDatabase(input: TrustedSetProjectDatabaseInput!): TrustedSetProjectDatabasePayload
  migrateProject(input: MigrateProjectInput!): MigrateProjectPayload
  updateModel(input: UpdateModelInput!): UpdateModelPayload
  updateRelation(input: UpdateRelationInput!): UpdateRelationPayload
  updateField(input: UpdateFieldInput!): UpdateFieldPayload
  addRelationFieldMirror(input: AddRelationFieldMirrorInput!): AddRelationFieldMirrorPayload
  deleteRelationFieldMirror(input: DeleteRelationFieldMirrorInput!): DeleteRelationFieldMirrorPayload
  addPermanentAuthToken(input: AddPermanentAuthTokenInput!): AddPermanentAuthTokenPayload
  deletePermanentAuthToken(input: DeletePermanentAuthTokenInput!): DeletePermanentAuthTokenPayload
  resetProjectData(input: ResetProjectDataInput!): ResetProjectDataPayload
  resetProjectSchema(input: ResetProjectSchemaInput!): ResetProjectSchemaPayload
  addAction(input: AddActionInput!): AddActionPayload
  updateAction(input: UpdateActionInput!): UpdateActionPayload
  deleteAction(input: DeleteActionInput!): DeleteActionPayload
  addModelPermission(input: AddModelPermissionInput!): AddModelPermissionPayload
  updateModelPermission(input: UpdateModelPermissionInput!): UpdateModelPermissionPayload
  deleteModelPermission(input: DeleteModelPermissionInput!): DeleteModelPermissionPayload
  updateAuthProvider(input: UpdateAuthProviderInput!): UpdateAuthProviderPayload
  updateSearchProviderAlgolia(input: UpdateSearchProviderAlgoliaInput!): UpdateSearchProviderAlgoliaPayload
  addAlgoliaSyncQuery(input: AddAlgoliaSyncQueryInput!): AddAlgoliaSyncQueryPayload
  deleteAlgoliaSyncQuery(input: DeleteAlgoliaSyncQueryInput!): DeleteAlgoliaSyncQueryPayload
  updateAlgoliaSyncQuery(input: UpdateAlgoliaSyncQueryInput!): UpdateAlgoliaSyncQueryPayload
  cloneProject(input: CloneProjectInput!): CloneProjectPayload
  exportData(input: ExportDataInput!): ExportDataPayload
  inviteCollaborator(input: InviteCollaboratorInput!): InviteCollaboratorPayload
  removeCollaborator(input: RemoveCollaboratorInput!): RemoveCollaboratorPayload
  setCreditCard(input: SetCreditCardInput!): SetCreditCardPayload
  deleteCreditCard(input: DeleteCreditCardInput!): DeleteCreditCardPayload
  setPlan(input: SetPlanInput!): SetPlanPayload
  generateUserToken(input: GenerateUserTokenInput!): GenerateUserTokenPayload
  deleteRelationPermission(input: DeleteRelationPermissionInput!): DeleteRelationPermissionPayload
  addRelationPermission(input: AddRelationPermissionInput!): AddRelationPermissionPayload
  updateRelationPermission(input: UpdateRelationPermissionInput!): UpdateRelationPermissionPayload
  installPackage(input: InstallPackageInput!): InstallPackagePayload
  uninstallPackage(input: UninstallPackageInput!): UninstallPackagePayload
  addEnum(input: AddEnumInput!): AddEnumPayload
  updateEnum(input: UpdateEnumInput!): UpdateEnumPayload
  deleteEnum(input: DeleteEnumInput!): DeleteEnumPayload
  addRequestPipelineMutationFunction(input: AddRequestPipelineMutationFunctionInput!): AddRequestPipelineMutationFunctionPayload
  updateRequestPipelineMutationFunction(input: UpdateRequestPipelineMutationFunctionInput!): UpdateRequestPipelineMutationFunctionPayload
  deleteFunction(input: DeleteFunctionInput!): DeleteFunctionPayload
  addServerSideSubscriptionFunction(input: AddServerSideSubscriptionFunctionInput!): AddServerSideSubscriptionFunctionPayload
  updateServerSideSubscriptionFunction(input: UpdateServerSideSubscriptionFunctionInput!): UpdateServerSideSubscriptionFunctionPayload
  trustedUpdateProject(input: TrustedUpdateProjectInput!): TrustedUpdateProjectPayload
  trustedSetFeatureToggle(input: TrustedSetFeatureToggleInput!): TrustedSetFeatureTogglePayload
  addFieldConstraint(input: AddFieldConstraintInput!): AddFieldConstraintPayload
  deleteFieldConstraint(input: DeleteFieldConstraintInput!): DeleteFieldConstraintPayload
  updateFieldConstraint(input: UpdateFieldConstraintInput!): UpdateFieldConstraintPayload
  addCustomMutationFunction(input: AddCustomMutationFunctionInput!): AddCustomMutationFunctionPayload
  updateCustomMutationFunction(input: UpdateCustomMutationFunctionInput!): UpdateCustomMutationFunctionPayload
  addCustomQueryFunction(input: AddCustomQueryFunctionInput!): AddCustomQueryFunctionPayload
  updateCustomQueryFunction(input: UpdateCustomQueryFunctionInput!): UpdateCustomQueryFunctionPayload
  addSchemaExtensionFunction(input: AddSchemaExtensionFunctionInput!): AddSchemaExtensionFunctionPayload
  updateSchemaExtensionFunction(input: UpdateSchemaExtensionFunctionInput!): UpdateSchemaExtensionFunctionPayload
  updateCrmCustomerInformation(input: UpdateCrmCustomerInformationInput!): UpdateCrmCustomerInformationPayload!
  updateCrmGuideStatus(input: UpdateCrmGuideStatusInput!): UpdateCrmGuideStatusPayload!
  updateCrmOnboardingStatus(input: UpdateCrmOnboardingStatusInput!): UpdateCrmOnboardingStatusPayload!
}

# An object with an ID
interface Node {
  # The id of the object.
  id: ID!
}

# This is a NumberConstraint
type NumberConstraint implements Node, FieldConstraint {
  equalsNumber: Float
  oneOfNumber: [Float!]
  min: Float
  max: Float
  exclusiveMin: Float
  exclusiveMax: Float
  multipleOf: Float

  # The id of the object.
  id: ID!
  constraintType: FieldConstraintTypeType!
  fieldId: ID!
}

enum ONBOARDING_STATUS_GETTING_STARTED {
  STEP0_OVERVIEW
  STEP1_CREATE_POST_MODEL
  STEP2_CLICK_CONFIRM_IMAGEURL
  STEP2_CLICK_CREATE_FIELD_IMAGEURL
  STEP2_CREATE_FIELD_DESCRIPTION
  STEP2_ENTER_FIELD_NAME_IMAGEURL
  STEP2_SELECT_TYPE_IMAGEURL
  STEP3_CLICK_ADD_NODE1
  STEP3_CLICK_ADD_NODE2
  STEP3_CLICK_DATA_BROWSER
  STEP3_CLICK_ENTER_DESCRIPTION
  STEP3_CLICK_ENTER_IMAGEURL
  STEP3_CLICK_SAVE_NODE1
  STEP4_CLICK_BEGIN_PART1
  STEP4_CLICK_BEGIN_PART2
  STEP4_CLICK_PLAYGROUND
  STEP4_CLICK_TEASER_PART2
  STEP4_CLICK_TEASER_STEP5
  STEP4_WAITING_PART1
  STEP4_WAITING_PART2
  STEP5_DONE
  STEP5_SELECT_EXAMPLE
  STEP5_WAITING
  STEP6_CLOSED
  STEP3_CLICK_POST_MODEL
  STEP2_ENTER_FIELD_NAME_DESCRIPTION
  STEP2_SELECT_TYPE_DESCRIPTION
  STEP2_CLICK_CONFIRM_DESCRIPTION
  STEP3_OPEN_PLAYGROUND
  STEP3_UNCOMMENT_DESCRIPTION
  STEP3_RUN_QUERY1
  STEP3_CREATE_MUTATION_TAB
  STEP3_ENTER_MUTATION1_VALUES
  STEP3_RUN_MUTATION1
  STEP3_ENTER_MUTATION2_VALUE
  STEP3_RUN_MUTATION2
  STEP3_SELECT_QUERY_TAB
  STEP3_RUN_QUERY2
  STEP3_OPEN_FINAL_POPUP
}

enum ONBOARDING_STATUS_GETTING_STARTED_EXAMPLE {
  AngularApollo
  ReactApollo
  ReactNativeApollo
  ReactRelay
  VueApollo
}

input OnboardingStatusFilter {
  # Logical AND on all given filters.
  AND: [OnboardingStatusFilter!]

  # Logical OR on all given filters.
  OR: [OnboardingStatusFilter!]
  createdAt: DateTime

  # All values that are not equal to given value.
  createdAt_not: DateTime

  # All values that are contained in given list.
  createdAt_in: [DateTime!]

  # All values that are not contained in given list.
  createdAt_not_in: [DateTime!]

  # All values less than the given value.
  createdAt_lt: DateTime

  # All values less than or equal the given value.
  createdAt_lte: DateTime

  # All values greater than the given value.
  createdAt_gt: DateTime

  # All values greater than or equal the given value.
  createdAt_gte: DateTime
  gettingStarted: ONBOARDING_STATUS_GETTING_STARTED

  # All values that are not equal to given value.
  gettingStarted_not: ONBOARDING_STATUS_GETTING_STARTED

  # All values that are contained in given list.
  gettingStarted_in: [ONBOARDING_STATUS_GETTING_STARTED!]

  # All values that are not contained in given list.
  gettingStarted_not_in: [ONBOARDING_STATUS_GETTING_STARTED!]
  gettingStartedCompleted: Boolean

  # All values that are not equal to given value.
  gettingStartedCompleted_not: Boolean
  gettingStartedExample: ONBOARDING_STATUS_GETTING_STARTED_EXAMPLE

  # All values that are not equal to given value.
  gettingStartedExample_not: ONBOARDING_STATUS_GETTING_STARTED_EXAMPLE

  # All values that are contained in given list.
  gettingStartedExample_in: [ONBOARDING_STATUS_GETTING_STARTED_EXAMPLE!]

  # All values that are not contained in given list.
  gettingStartedExample_not_in: [ONBOARDING_STATUS_GETTING_STARTED_EXAMPLE!]
  gettingStartedSkipped: Boolean

  # All values that are not equal to given value.
  gettingStartedSkipped_not: Boolean
  id: ID

  # All values that are not equal to given value.
  id_not: ID

  # All values that are contained in given list.
  id_in: [ID!]

  # All values that are not contained in given list.
  id_not_in: [ID!]

  # All values less than the given value.
  id_lt: ID

  # All values less than or equal the given value.
  id_lte: ID

  # All values greater than the given value.
  id_gt: ID

  # All values greater than or equal the given value.
  id_gte: ID

  # All values containing the given string.
  id_contains: ID

  # All values not containing the given string.
  id_not_contains: ID

  # All values starting with the given string.
  id_starts_with: ID

  # All values not starting with the given string.
  id_not_starts_with: ID

  # All values ending with the given string.
  id_ends_with: ID

  # All values not ending with the given string.
  id_not_ends_with: ID
  updatedAt: DateTime

  # All values that are not equal to given value.
  updatedAt_not: DateTime

  # All values that are contained in given list.
  updatedAt_in: [DateTime!]

  # All values that are not contained in given list.
  updatedAt_not_in: [DateTime!]

  # All values less than the given value.
  updatedAt_lt: DateTime

  # All values less than or equal the given value.
  updatedAt_lte: DateTime

  # All values greater than the given value.
  updatedAt_gt: DateTime

  # All values greater than or equal the given value.
  updatedAt_gte: DateTime
  systemBridge: SystemBridgeFilter
}

enum Operation {
  READ
  CREATE
  UPDATE
  DELETE
}

# this is a beta feature. Expect breaking changes.
type PackageDefinition implements Node {
  id: ID!
  definition: String!
  name: String
}

# A connection to a list of items.
type PackageDefinitionConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [PackageDefinitionEdge]
}

# An edge in a connection.
type PackageDefinitionEdge {
  # The item at the end of the edge.
  node: PackageDefinition!

  # A cursor for use in pagination.
  cursor: String!
}

# Information about pagination in a connection.
type PageInfo {
  # When paginating forwards, are there more items?
  hasNextPage: Boolean!

  # When paginating backwards, are there more items?
  hasPreviousPage: Boolean!

  # When paginating backwards, the cursor to continue.
  startCursor: String

  # When paginating forwards, the cursor to continue.
  endCursor: String
}

# Used to grant permanent access to your applications and services
type PermanentAuthToken implements Node {
  id: ID!
  name: String!
  token: String!
}

# A connection to a list of items.
type PermanentAuthTokenConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [PermanentAuthTokenEdge]
}

# An edge in a connection.
type PermanentAuthTokenEdge {
  # The item at the end of the edge.
  node: PermanentAuthToken!

  # A cursor for use in pagination.
  cursor: String!
}

# PermissionQueryArgument
type PermissionQueryArgument {
  name: String!
  typeName: String!
  group: String!
}

# This is a project
type Project implements Node {
  id: ID!
  name: String!
  alias: String
  version: Int!
  region: Region!
  projectDatabase: ProjectDatabase!
  schema: String!
  typeSchema: String!
  enumSchema: String!
  isGlobalEnumsEnabled: Boolean!
  webhookUrl: String
  seats(before: String, after: String, first: Int, last: Int): SeatConnection!
  integrations(before: String, after: String, first: Int, last: Int): IntegrationConnection!
  authProviders(before: String, after: String, first: Int, last: Int): AuthProviderConnection!
  fields(before: String, after: String, first: Int, last: Int): FieldConnection!
  models(before: String, after: String, first: Int, last: Int): ModelConnection!
  enums(before: String, after: String, first: Int, last: Int): EnumConnection!
  packageDefinitions(before: String, after: String, first: Int, last: Int): PackageDefinitionConnection!
  relations(before: String, after: String, first: Int, last: Int): RelationConnection!
  permanentAuthTokens(before: String, after: String, first: Int, last: Int): PermanentAuthTokenConnection!
  functions(before: String, after: String, first: Int, last: Int): FunctionConnection!
  featureToggles(before: String, after: String, first: Int, last: Int): FeatureToggleConnection!
  actions(before: String, after: String, first: Int, last: Int): ActionConnection!
  actionSchema(modelId: ID!, modelMutationType: ActionTriggerMutationModelMutationType!): String!
  allowMutations: Boolean!
  availableUserRoles: [String!]!
  functionRequestHistogram(period: HistogramPeriod!): [Int!]!
}

input ProjectBillingInformationFilter {
  # Logical AND on all given filters.
  AND: [ProjectBillingInformationFilter!]

  # Logical OR on all given filters.
  OR: [ProjectBillingInformationFilter!]
  createdAt: DateTime

  # All values that are not equal to given value.
  createdAt_not: DateTime

  # All values that are contained in given list.
  createdAt_in: [DateTime!]

  # All values that are not contained in given list.
  createdAt_not_in: [DateTime!]

  # All values less than the given value.
  createdAt_lt: DateTime

  # All values less than or equal the given value.
  createdAt_lte: DateTime

  # All values greater than the given value.
  createdAt_gt: DateTime

  # All values greater than or equal the given value.
  createdAt_gte: DateTime
  id: ID

  # All values that are not equal to given value.
  id_not: ID

  # All values that are contained in given list.
  id_in: [ID!]

  # All values that are not contained in given list.
  id_not_in: [ID!]

  # All values less than the given value.
  id_lt: ID

  # All values less than or equal the given value.
  id_lte: ID

  # All values greater than the given value.
  id_gt: ID

  # All values greater than or equal the given value.
  id_gte: ID

  # All values containing the given string.
  id_contains: ID

  # All values not containing the given string.
  id_not_contains: ID

  # All values starting with the given string.
  id_starts_with: ID

  # All values not starting with the given string.
  id_not_starts_with: ID

  # All values ending with the given string.
  id_ends_with: ID

  # All values not ending with the given string.
  id_not_ends_with: ID
  plan: String

  # All values that are not equal to given value.
  plan_not: String

  # All values that are contained in given list.
  plan_in: [String!]

  # All values that are not contained in given list.
  plan_not_in: [String!]

  # All values less than the given value.
  plan_lt: String

  # All values less than or equal the given value.
  plan_lte: String

  # All values greater than the given value.
  plan_gt: String

  # All values greater than or equal the given value.
  plan_gte: String

  # All values containing the given string.
  plan_contains: String

  # All values not containing the given string.
  plan_not_contains: String

  # All values starting with the given string.
  plan_starts_with: String

  # All values not starting with the given string.
  plan_not_starts_with: String

  # All values ending with the given string.
  plan_ends_with: String

  # All values not ending with the given string.
  plan_not_ends_with: String
  stripeCustomerId: String

  # All values that are not equal to given value.
  stripeCustomerId_not: String

  # All values that are contained in given list.
  stripeCustomerId_in: [String!]

  # All values that are not contained in given list.
  stripeCustomerId_not_in: [String!]

  # All values less than the given value.
  stripeCustomerId_lt: String

  # All values less than or equal the given value.
  stripeCustomerId_lte: String

  # All values greater than the given value.
  stripeCustomerId_gt: String

  # All values greater than or equal the given value.
  stripeCustomerId_gte: String

  # All values containing the given string.
  stripeCustomerId_contains: String

  # All values not containing the given string.
  stripeCustomerId_not_contains: String

  # All values starting with the given string.
  stripeCustomerId_starts_with: String

  # All values not starting with the given string.
  stripeCustomerId_not_starts_with: String

  # All values ending with the given string.
  stripeCustomerId_ends_with: String

  # All values not ending with the given string.
  stripeCustomerId_not_ends_with: String
  updatedAt: DateTime

  # All values that are not equal to given value.
  updatedAt_not: DateTime

  # All values that are contained in given list.
  updatedAt_in: [DateTime!]

  # All values that are not contained in given list.
  updatedAt_not_in: [DateTime!]

  # All values less than the given value.
  updatedAt_lt: DateTime

  # All values less than or equal the given value.
  updatedAt_lte: DateTime

  # All values greater than the given value.
  updatedAt_gt: DateTime

  # All values greater than or equal the given value.
  updatedAt_gte: DateTime
  creditCard: CreditCardFilter
  invoices_every: InvoiceFilter
  invoices_some: InvoiceFilter
  invoices_none: InvoiceFilter
  project: ProjectFilter
}

# A connection to a list of items.
type ProjectConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [ProjectEdge]
}

# This is the database for a project
type ProjectDatabase implements Node {
  id: ID!
  name: String!
  region: Region!
}

# An edge in a connection.
type ProjectEdge {
  # The item at the end of the edge.
  node: Project!

  # A cursor for use in pagination.
  cursor: String!
}

input ProjectFilter {
  # Logical AND on all given filters.
  AND: [ProjectFilter!]

  # Logical OR on all given filters.
  OR: [ProjectFilter!]
  createdAt: DateTime

  # All values that are not equal to given value.
  createdAt_not: DateTime

  # All values that are contained in given list.
  createdAt_in: [DateTime!]

  # All values that are not contained in given list.
  createdAt_not_in: [DateTime!]

  # All values less than the given value.
  createdAt_lt: DateTime

  # All values less than or equal the given value.
  createdAt_lte: DateTime

  # All values greater than the given value.
  createdAt_gt: DateTime

  # All values greater than or equal the given value.
  createdAt_gte: DateTime
  id: ID

  # All values that are not equal to given value.
  id_not: ID

  # All values that are contained in given list.
  id_in: [ID!]

  # All values that are not contained in given list.
  id_not_in: [ID!]

  # All values less than the given value.
  id_lt: ID

  # All values less than or equal the given value.
  id_lte: ID

  # All values greater than the given value.
  id_gt: ID

  # All values greater than or equal the given value.
  id_gte: ID

  # All values containing the given string.
  id_contains: ID

  # All values not containing the given string.
  id_not_contains: ID

  # All values starting with the given string.
  id_starts_with: ID

  # All values not starting with the given string.
  id_not_starts_with: ID

  # All values ending with the given string.
  id_ends_with: ID

  # All values not ending with the given string.
  id_not_ends_with: ID
  isDeleted: Boolean

  # All values that are not equal to given value.
  isDeleted_not: Boolean
  name: String

  # All values that are not equal to given value.
  name_not: String

  # All values that are contained in given list.
  name_in: [String!]

  # All values that are not contained in given list.
  name_not_in: [String!]

  # All values less than the given value.
  name_lt: String

  # All values less than or equal the given value.
  name_lte: String

  # All values greater than the given value.
  name_gt: String

  # All values greater than or equal the given value.
  name_gte: String

  # All values containing the given string.
  name_contains: String

  # All values not containing the given string.
  name_not_contains: String

  # All values starting with the given string.
  name_starts_with: String

  # All values not starting with the given string.
  name_not_starts_with: String

  # All values ending with the given string.
  name_ends_with: String

  # All values not ending with the given string.
  name_not_ends_with: String
  systemProjectId: String

  # All values that are not equal to given value.
  systemProjectId_not: String

  # All values that are contained in given list.
  systemProjectId_in: [String!]

  # All values that are not contained in given list.
  systemProjectId_not_in: [String!]

  # All values less than the given value.
  systemProjectId_lt: String

  # All values less than or equal the given value.
  systemProjectId_lte: String

  # All values greater than the given value.
  systemProjectId_gt: String

  # All values greater than or equal the given value.
  systemProjectId_gte: String

  # All values containing the given string.
  systemProjectId_contains: String

  # All values not containing the given string.
  systemProjectId_not_contains: String

  # All values starting with the given string.
  systemProjectId_starts_with: String

  # All values not starting with the given string.
  systemProjectId_not_starts_with: String

  # All values ending with the given string.
  systemProjectId_ends_with: String

  # All values not ending with the given string.
  systemProjectId_not_ends_with: String
  updatedAt: DateTime

  # All values that are not equal to given value.
  updatedAt_not: DateTime

  # All values that are contained in given list.
  updatedAt_in: [DateTime!]

  # All values that are not contained in given list.
  updatedAt_not_in: [DateTime!]

  # All values less than the given value.
  updatedAt_lt: DateTime

  # All values less than or equal the given value.
  updatedAt_lte: DateTime

  # All values greater than the given value.
  updatedAt_gt: DateTime

  # All values greater than or equal the given value.
  updatedAt_gte: DateTime
  customer: CustomerFilter
  projectBillingInformation: ProjectBillingInformationFilter
}

enum ProjectOrderBy {
  createdAt_ASC
  createdAt_DESC
  id_ASC
  id_DESC
  isDeleted_ASC
  isDeleted_DESC
  name_ASC
  name_DESC
  systemProjectId_ASC
  systemProjectId_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type Query {
  viewer: Viewer!

  # Fetches an object given its ID
  node(
    # The ID of an object
    id: ID!
  ): Node
}

enum Region {
  EU_WEST_1
  AP_NORTHEAST_1
  US_WEST_2
}

# This is a relation
type Relation implements Node {
  id: ID!
  leftModel: Model!
  fieldOnLeftModel: Field!
  rightModel: Model!
  fieldOnRightModel: Field!
  permissions(before: String, after: String, first: Int, last: Int): RelationPermissionConnection!
  name: String!
  description: String
  fieldMirrors: [RelationFieldMirror!]!
  permissionSchema: String!
  permissionQueryArguments: [PermissionQueryArgument!]!
}

# A connection to a list of items.
type RelationConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [RelationEdge]
}

# An edge in a connection.
type RelationEdge {
  # The item at the end of the edge.
  node: Relation!

  # A cursor for use in pagination.
  cursor: String!
}

# This is a relation field mirror
type RelationFieldMirror implements Node {
  id: ID!
  fieldId: ID!
  relationId: ID!
}

# A connection to a list of items.
type RelationFieldMirrorConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [RelationFieldMirrorEdge]
}

# An edge in a connection.
type RelationFieldMirrorEdge {
  # The item at the end of the edge.
  node: RelationFieldMirror!

  # A cursor for use in pagination.
  cursor: String!
}

# This is a relation permission
type RelationPermission implements Node {
  id: ID!
  ruleWebhookUrl: String
  rule: Rule!
  ruleName: String
  ruleGraphQuery: String
  isActive: Boolean!
  connect: Boolean!
  disconnect: Boolean!
  userType: UserType!
  description: String
  relation: Relation!
}

# A connection to a list of items.
type RelationPermissionConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [RelationPermissionEdge]
}

# An edge in a connection.
type RelationPermissionEdge {
  # The item at the end of the edge.
  node: RelationPermission!

  # A cursor for use in pagination.
  cursor: String!
}

enum RelationSide {
  A
  B
}

input RemoveCollaboratorInput {
  projectId: ID!
  email: String!
  clientMutationId: String
}

type RemoveCollaboratorPayload {
  viewer: Viewer!
  deletedId: String!
  project: Project!
  seatConnection(before: String, after: String, first: Int, last: Int): SeatConnection!
  clientMutationId: String
}

# This is a RequestPipelineMutationFunction
type RequestPipelineMutationFunction implements Node, Function {
  model: Model!
  binding: FunctionBinding!
  operation: RequestPipelineMutationOperation!

  # The id of the object.
  id: ID!
  logs(before: String, after: String, first: Int, last: Int): LogConnection!
  stats(before: String, after: String, first: Int, last: Int): FunctionStats!
  name: String!
  type: FunctionType!
  isActive: Boolean!
  webhookUrl: String
  webhookHeaders: String
  inlineCode: String
  auth0Id: String
}

enum RequestPipelineMutationOperation {
  CREATE
  UPDATE
  DELETE
}

input ResetPasswordInput {
  resetPasswordToken: String!
  newPassword: String!
  clientMutationId: String
}

type ResetPasswordPayload {
  viewer: Viewer!
  user: Customer!
  token: String!
  clientMutationId: String
}

input ResetProjectDataInput {
  projectId: String!
  clientMutationId: String
}

type ResetProjectDataPayload {
  viewer: Viewer!
  user: Customer!
  project: Project!
  projectConnection(before: String, after: String, first: Int, last: Int): ProjectConnection!
  projectEdge: ProjectEdge!
  clientMutationId: String
}

input ResetProjectSchemaInput {
  projectId: String!
  clientMutationId: String
}

type ResetProjectSchemaPayload {
  viewer: Viewer!
  user: Customer!
  project: Project!
  projectConnection(before: String, after: String, first: Int, last: Int): ProjectConnection!
  projectEdge: ProjectEdge!
  clientMutationId: String
}

enum Rule {
  NONE
  GRAPH
  WEBHOOK
}

# An error that occurred while validating the schema.
type SchemaError {
  type: String!
  field: String
  description: String!
}

# This is a SchemaExtensionFunction
type SchemaExtensionFunction implements Node, Function {
  schema: String!

  # The id of the object.
  id: ID!
  logs(before: String, after: String, first: Int, last: Int): LogConnection!
  stats(before: String, after: String, first: Int, last: Int): FunctionStats!
  name: String!
  type: FunctionType!
  isActive: Boolean!
  webhookUrl: String
  webhookHeaders: String
  inlineCode: String
  auth0Id: String
}

# This is a SearchProviderAlgolia
type SearchProviderAlgolia implements Node, Integration {
  id: ID!
  applicationId: String!
  apiKey: String!
  algoliaSyncQueries(before: String, after: String, first: Int, last: Int): AlgoliaSyncQueryConnection!
  algoliaSchema(modelId: ID!): String!
  isEnabled: Boolean!
  name: IntegrationNameType!
  type: IntegrationTypeType!
}

# This is a seat
type Seat implements Node {
  id: ID!
  isOwner: Boolean!
  email: String!
  name: String
  status: SeatStatus!
}

# A connection to a list of items.
type SeatConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [SeatEdge]
}

# An edge in a connection.
type SeatEdge {
  # The item at the end of the edge.
  node: Seat!

  # A cursor for use in pagination.
  cursor: String!
}

enum SeatStatus {
  JOINED
  INVITED_TO_PROJECT
  INVITED_TO_GRAPHCOOL
}

# This is a ServerSideSubscriptionFunction
type ServerSideSubscriptionFunction implements Node, Function {
  query: String!

  # The id of the object.
  id: ID!
  logs(before: String, after: String, first: Int, last: Int): LogConnection!
  stats(before: String, after: String, first: Int, last: Int): FunctionStats!
  name: String!
  type: FunctionType!
  isActive: Boolean!
  webhookUrl: String
  webhookHeaders: String
  inlineCode: String
  auth0Id: String
}

input SetCreditCardInput {
  projectId: ID!
  token: String!
  clientMutationId: String
}

type SetCreditCardPayload {
  viewer: Viewer!
  project: Project!
  user: Customer!
  clientMutationId: String
}

input SetPlanInput {
  projectId: ID!
  plan: String!
  clientMutationId: String
}

type SetPlanPayload {
  viewer: Viewer!
  project: Project!
  user: Customer!
  plan: String!
  clientMutationId: String
}

input SigninClientUserInput {
  projectId: ID!
  clientUserId: ID!
  clientMutationId: String
}

type SigninClientUserPayload {
  token: String!
  clientMutationId: String
}

input SigninCustomerInput {
  email: String!
  password: String!
  clientMutationId: String
}

type SigninCustomerPayload {
  token: String!
  viewer: Viewer!
  clientMutationId: String
}

input SignupCustomerInput {
  email: String!
  name: String!
  source: CustomerSourceType!
  clientMutationId: String
}

type SignupCustomerPayload {
  viewer: Viewer!
  user: Customer!
  userEdge: ClientEdge!
  resetPasswordToken: String!
  clientMutationId: String
}

# This is a StringConstraint
type StringConstraint implements Node, FieldConstraint {
  equalsString: String
  oneOfString: [String!]
  minLength: Int
  maxLength: Int
  startsWith: String
  endsWith: String
  includes: String
  regex: String

  # The id of the object.
  id: ID!
  constraintType: FieldConstraintTypeType!
  fieldId: ID!
}

input SystemBridgeFilter {
  # Logical AND on all given filters.
  AND: [SystemBridgeFilter!]

  # Logical OR on all given filters.
  OR: [SystemBridgeFilter!]
  id: ID

  # All values that are not equal to given value.
  id_not: ID

  # All values that are contained in given list.
  id_in: [ID!]

  # All values that are not contained in given list.
  id_not_in: [ID!]

  # All values less than the given value.
  id_lt: ID

  # All values less than or equal the given value.
  id_lte: ID

  # All values greater than the given value.
  id_gt: ID

  # All values greater than or equal the given value.
  id_gte: ID

  # All values containing the given string.
  id_contains: ID

  # All values not containing the given string.
  id_not_contains: ID

  # All values starting with the given string.
  id_starts_with: ID

  # All values not starting with the given string.
  id_not_starts_with: ID

  # All values ending with the given string.
  id_ends_with: ID

  # All values not ending with the given string.
  id_not_ends_with: ID
  systemCustomerId: String

  # All values that are not equal to given value.
  systemCustomerId_not: String

  # All values that are contained in given list.
  systemCustomerId_in: [String!]

  # All values that are not contained in given list.
  systemCustomerId_not_in: [String!]

  # All values less than the given value.
  systemCustomerId_lt: String

  # All values less than or equal the given value.
  systemCustomerId_lte: String

  # All values greater than the given value.
  systemCustomerId_gt: String

  # All values greater than or equal the given value.
  systemCustomerId_gte: String

  # All values containing the given string.
  systemCustomerId_contains: String

  # All values not containing the given string.
  systemCustomerId_not_contains: String

  # All values starting with the given string.
  systemCustomerId_starts_with: String

  # All values not starting with the given string.
  systemCustomerId_not_starts_with: String

  # All values ending with the given string.
  systemCustomerId_ends_with: String

  # All values not ending with the given string.
  systemCustomerId_not_ends_with: String
  customer: CustomerFilter
  guideStatus: GuideStatusFilter
  information: CustomerInformationFilter
  onboardingStatus: OnboardingStatusFilter
}

input TrustedSetFeatureToggleInput {
  projectId: String!
  name: String!
  isEnabled: Boolean!
  secret: String!
  clientMutationId: String
}

type TrustedSetFeatureTogglePayload {
  viewer: Viewer!
  project: Project!
  featureToggle: FeatureToggle!
  clientMutationId: String
}

input TrustedSetProjectDatabaseInput {
  projectId: String!
  projectDatabaseId: String!
  secret: String!
  clientMutationId: String
}

type TrustedSetProjectDatabasePayload {
  viewer: Viewer!
  project: Project!
  user: Customer!
  clientMutationId: String
}

input TrustedSigninCustomerInput {
  email: String!
  secret: String!
  clientMutationId: String
}

type TrustedSigninCustomerPayload {
  token: String!
  resetPasswordToken: String!
  viewer: Viewer!
  clientMutationId: String
}

input TrustedSignupCustomerInput {
  email: String!
  name: String
  source: CustomerSourceType!
  secret: String!
  clientMutationId: String
}

type TrustedSignupCustomerPayload {
  viewer: Viewer!
  client: Customer!
  clientEdge: ClientEdge!
  resetPasswordToken: String!
  token: String!
  clientMutationId: String
}

input TrustedUpdateProjectInput {
  id: String!
  name: String
  alias: String
  webhookUrl: String
  allowQueries: Boolean
  allowMutations: Boolean
  secret: String!
  clientMutationId: String
}

type TrustedUpdateProjectPayload {
  viewer: Viewer!
  project: Project!
  user: Customer!
  clientMutationId: String
}

input UninstallPackageInput {
  projectId: ID!
  name: String!
  clientMutationId: String
}

type UninstallPackagePayload {
  viewer: Viewer!
  project: Project!
  user: Customer!
  packageDefinition: PackageDefinition!
  packageDefinitionConnection(before: String, after: String, first: Int, last: Int): PackageDefinitionConnection!
  clientMutationId: String
}

input UpdateActionInput {
  actionId: ID!
  isActive: Boolean
  description: String
  triggerType: ActionTriggerType
  handlerType: ActionHandlerType
  handlerWebhook: ActionHandlerWebhookEmbed
  triggerMutationModel: ActionTriggerModelMutationEmbed
  clientMutationId: String
}

type UpdateActionPayload {
  viewer: Viewer!
  project: Project!
  user: Customer!
  action: Action!
  actionConnection(before: String, after: String, first: Int, last: Int): ActionConnection!
  actionEdge: ActionEdge!
  clientMutationId: String
}

input UpdateAlgoliaSyncQueryInput {
  algoliaSyncQueryId: String!
  indexName: String!
  fragment: String!
  isEnabled: Boolean!
  clientMutationId: String
}

type UpdateAlgoliaSyncQueryPayload {
  viewer: Viewer!
  project: Project!
  algoliaSyncQuery: AlgoliaSyncQuery!
  searchProviderAlgolia: SearchProviderAlgolia!
  user: Customer!
  algoliaSyncQueryConnection(before: String, after: String, first: Int, last: Int): AlgoliaSyncQueryConnection!
  algoliaSyncQueryEdge: AlgoliaSyncQueryEdge!
  clientMutationId: String
}

input UpdateAuthProviderInput {
  id: ID!
  isEnabled: Boolean!
  digits: AuthProviderDigitsMetaInput
  auth0: AuthProviderAuth0MetaInput
  clientMutationId: String
}

type UpdateAuthProviderPayload {
  viewer: Viewer!
  project: Project!
  authProvider: AuthProvider!
  authProviderEdge: AuthProviderEdge!
  user: Customer!
  clientMutationId: String
}

input UpdateCrmCustomerInformationInput {
  createdAt: DateTime
  email: String
  isBeta: Boolean
  name: String
  referral: String
  signupPath: String
  signupSource: CUSTOMER_INFORMATION_SIGNUP_SOURCE
  source: String
  updatedAt: DateTime
  clientMutationId: String!
}

type UpdateCrmCustomerInformationPayload {
  clientMutationId: String!
  customerInformation: crm_CustomerInformation
}

input UpdateCrmGuideStatusInput {
  guide1: Boolean
  clientMutationId: String!
}

type UpdateCrmGuideStatusPayload {
  clientMutationId: String!
  guideStatus: crm_GuideStatus
}

input UpdateCrmOnboardingStatusInput {
  gettingStarted: ONBOARDING_STATUS_GETTING_STARTED
  gettingStartedCompleted: Boolean
  gettingStartedExample: ONBOARDING_STATUS_GETTING_STARTED_EXAMPLE
  gettingStartedSkipped: Boolean
  clientMutationId: String!
}

type UpdateCrmOnboardingStatusPayload {
  clientMutationId: String!
  onboardingStatus: crm_OnboardingStatus
}

input UpdateCustomerInput {
  name: String
  email: String
  clientMutationId: String
}

type UpdateCustomerPayload {
  viewer: Viewer!
  user: Customer!
  clientMutationId: String
}

input UpdateCustomMutationFunctionInput {
  functionId: ID!
  name: String
  isActive: Boolean
  schema: String
  type: FunctionType
  webhookUrl: String
  webhookHeaders: String
  inlineCode: String
  auth0Id: String
  clientMutationId: String
}

type UpdateCustomMutationFunctionPayload {
  viewer: Viewer!
  project: Project!
  user: Customer!
  function: CustomMutationFunction!
  functionEdge: FunctionEdge!
  clientMutationId: String
}

input UpdateCustomQueryFunctionInput {
  functionId: ID!
  name: String
  isActive: Boolean
  schema: String
  type: FunctionType
  webhookUrl: String
  webhookHeaders: String
  inlineCode: String
  auth0Id: String
  clientMutationId: String
}

type UpdateCustomQueryFunctionPayload {
  viewer: Viewer!
  project: Project!
  user: Customer!
  function: CustomQueryFunction!
  functionEdge: FunctionEdge!
  clientMutationId: String
}

input UpdateEnumInput {
  enumId: ID!
  name: String
  values: [String!]
  migrationValue: String
  clientMutationId: String
}

type UpdateEnumPayload {
  viewer: Viewer!
  project: Project!
  enum: Enum!
  enumEdge: EnumEdge!
  clientMutationId: String
}

input UpdateFieldConstraintInput {
  constraintId: ID!
  equalsString: String
  oneOfString: [String!]
  minLength: Int
  maxLength: Int
  startsWith: String
  endsWith: String
  includes: String
  regex: String
  equalsNumber: Float
  oneOfNumber: [Float!]
  min: Float
  max: Float
  exclusiveMin: Float
  exclusiveMax: Float
  multipleOf: Float
  equalsBoolean: Boolean
  uniqueItems: Boolean
  minItems: Int
  maxItems: Int
  clientMutationId: String
}

type UpdateFieldConstraintPayload {
  viewer: Viewer!
  project: Project!
  field: Field!
  constraints: [FieldConstraint!]!
  clientMutationId: String
}

input UpdateFieldInput {
  id: String!
  defaultValue: String
  migrationValue: String
  description: String
  name: String
  typeIdentifier: String
  isUnique: Boolean
  isRequired: Boolean
  isList: Boolean
  enumId: ID
  clientMutationId: String
}

type UpdateFieldPayload {
  viewer: Viewer!
  model: Model!
  field: Field!
  user: Customer!
  fieldConnection(before: String, after: String, first: Int, last: Int): FieldConnection!
  fieldEdge: FieldEdge!
  clientMutationId: String
}

input UpdateModelInput {
  id: String!
  description: String
  name: String
  clientMutationId: String
}

type UpdateModelPayload {
  viewer: Viewer!
  project: Project!
  model: Model!
  user: Customer!
  modelConnection(before: String, after: String, first: Int, last: Int): ModelConnection!
  modelEdge: ModelEdge!
  clientMutationId: String
}

input UpdateModelPermissionInput {
  id: ID!
  operation: Operation
  userType: UserType
  rule: Rule
  ruleName: String
  ruleGraphQuery: String
  ruleWebhookUrl: String
  fieldIds: [String!]
  applyToWholeModel: Boolean
  description: String
  isActive: Boolean
  clientMutationId: String
}

type UpdateModelPermissionPayload {
  viewer: Viewer!
  model: Model!
  modelPermission: ModelPermission!
  user: Customer!
  modelPermissionConnection(before: String, after: String, first: Int, last: Int): ModelPermissionConnection!
  modelPermissionEdge: ModelPermissionEdge!
  clientMutationId: String
}

input UpdatePasswordInput {
  oldPassword: String!
  newPassword: String!
  clientMutationId: String
}

type UpdatePasswordPayload {
  viewer: Viewer!
  user: Customer!
  clientMutationId: String
}

input UpdateProjectInput {
  id: String!
  name: String
  alias: String
  webhookUrl: String
  allowQueries: Boolean
  allowMutations: Boolean
  clientMutationId: String
}

type UpdateProjectPayload {
  viewer: Viewer!
  project: Project!
  user: Customer!
  projectConnection(before: String, after: String, first: Int, last: Int): ProjectConnection!
  projectEdge: ProjectEdge!
  clientMutationId: String
}

input UpdateRelationInput {
  id: ID!
  leftModelId: ID
  rightModelId: ID
  fieldOnLeftModelName: String
  fieldOnRightModelName: String
  fieldOnLeftModelIsList: Boolean
  fieldOnRightModelIsList: Boolean
  fieldOnLeftModelIsRequired: Boolean
  fieldOnRightModelIsRequired: Boolean
  name: String
  description: String
  clientMutationId: String
}

type UpdateRelationPayload {
  viewer: Viewer!
  project: Project!
  user: Customer!
  relation: Relation!
  leftModel: Model!
  rightModel: Model!
  modelConnection(before: String, after: String, first: Int, last: Int): ModelConnection!
  relationEdge: RelationEdge!
  leftModelEdge: ModelEdge!
  rightModelEdge: ModelEdge!
  fieldOnLeftModelEdge: FieldEdge!
  fieldOnRightModelEdge: FieldEdge!
  clientMutationId: String
}

input UpdateRelationPermissionInput {
  id: ID!
  connect: Boolean
  disconnect: Boolean
  userType: UserType
  rule: Rule
  ruleName: String
  ruleGraphQuery: String
  ruleWebhookUrl: String
  description: String
  isActive: Boolean
  clientMutationId: String
}

type UpdateRelationPermissionPayload {
  viewer: Viewer!
  relation: Relation!
  relationPermission: RelationPermission!
  user: Customer!
  relationPermissionConnection(before: String, after: String, first: Int, last: Int): RelationPermissionConnection!
  relationPermissionEdge: RelationPermissionEdge!
  clientMutationId: String
}

input UpdateRequestPipelineMutationFunctionInput {
  functionId: ID!
  name: String
  isActive: Boolean
  operation: RequestPipelineMutationOperation
  binding: FunctionBinding
  modelId: String
  type: FunctionType
  webhookUrl: String
  webhookHeaders: String
  inlineCode: String
  auth0Id: String
  clientMutationId: String
}

type UpdateRequestPipelineMutationFunctionPayload {
  viewer: Viewer!
  project: Project!
  user: Customer!
  function: RequestPipelineMutationFunction!
  functionEdge: FunctionEdge!
  clientMutationId: String
}

input UpdateSchemaExtensionFunctionInput {
  functionId: ID!
  name: String
  isActive: Boolean
  schema: String
  type: FunctionType
  webhookUrl: String
  webhookHeaders: String
  inlineCode: String
  auth0Id: String
  clientMutationId: String
}

type UpdateSchemaExtensionFunctionPayload {
  viewer: Viewer!
  project: Project!
  user: Customer!
  function: SchemaExtensionFunction!
  functionEdge: FunctionEdge!
  clientMutationId: String
}

input UpdateSearchProviderAlgoliaInput {
  projectId: String!
  applicationId: String!
  apiKey: String!
  isEnabled: Boolean!
  clientMutationId: String
}

type UpdateSearchProviderAlgoliaPayload {
  viewer: Viewer!
  project: Project!
  searchProviderAlgolia: SearchProviderAlgolia!
  user: Customer!
  clientMutationId: String
}

input UpdateServerSideSubscriptionFunctionInput {
  functionId: ID!
  name: String
  isActive: Boolean
  query: String
  type: FunctionType
  webhookUrl: String
  webhookHeaders: String
  inlineCode: String
  auth0Id: String
  clientMutationId: String
}

type UpdateServerSideSubscriptionFunctionPayload {
  viewer: Viewer!
  project: Project!
  user: Customer!
  function: ServerSideSubscriptionFunction!
  functionEdge: FunctionEdge!
  clientMutationId: String
}

enum UserType {
  EVERYONE
  AUTHENTICATED
}

# This is the famous Relay viewer object
type Viewer implements Node {
  id: ID!
  user: Customer
  project(id: ID!): Project
  projectByName(projectName: String!): Project
  model(id: ID!): Model
  modelByName(projectName: String!, modelName: String!): Model
  relation(id: ID!): Relation
  relationByName(projectName: String!, relationName: String!): Relation
  field(id: ID!): Field
  fieldByName(projectName: String!, modelName: String!, fieldName: String!): Field
}

